\documentclass{report}
\usepackage{mathtools}
\usepackage{unicode-math}
\usepackage{lualatex-math}
\usepackage{tcolorbox}
\setmainfont[
  BoldFont={STIXTwoText-Bold},
  ItalicFont={STIXTwoText-Italic},
  BoldItalicFont={STIXTwoText-BoldItalic}
]{STIXTwoText-Regular}
\setmathfont{STIXTwoMath-Regular}

\usepackage{mathdots}

\setlength{\parindent}{0pt}
\setlength{\parskip}{0.5em}

\usepackage{biblatex}
\addbibresource{references.bib}
\usepackage{amsmath}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  mathescape
}

\renewcommand{\chaptername}{Poglavje}

\DeclareMathOperator{\acc}{symbol}

\usepackage{mathtools}
\usepackage{tikz}
\usetikzlibrary{automata, backgrounds, arrows.meta, positioning, arrows, fit, matrix, shapes.geometric, shapes.misc, calc}
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

\newcounter{example}
%\newcommand{\N}[1]{{{#1}_{\arabic{example}}}}
\newcommand{\N}[1]{#1}
\newcommand{\Next}{\stepcounter{example}}
\newcommand{\Reset}{\setcounter{example}{1}}

\newcommand{\Ex}{\textbf{Npr.}:\ }
\newcommand{\Special}[1]{\textbf{#1}}
\newcommand{\Empty}{\varnothing}
\newcommand{\Null}{\varepsilon}
\newcommand{\Language}[1]{\mathcal{L}(#1)}
\newcommand{\Automaton}[1]{\mathcal{M}(#1)}
\newcommand{\Str}[1]{\text{\textquotedbl\texttt{#1}\textquotedbl}}
\newcommand{\Char}[1]{\texttt{#1}}
\newcommand{\Seq}{\cdot}
\newcommand{\Pos}{\mathop{\mdsmblkcircle}}
\newcommand{\Spc}{\ }
\newcommand{\Union}{\mathrel{|}}
\newcommand{\Sum}{\mathrel{+}}
\newcommand{\Kleene}[1]{{#1}^\ast}
\newcommand{\Rep}[2]{{#1}^{#2}}
\newcommand{\Opt}[1]{#1?}
\newcommand{\KleenePlus}[1]{#1^+}
\newcommand{\Err}{\rdiagovfdiag}

\newcommand{\Set}[1]{\symbf{#1}}
\newcommand{\Alphabet}{\Set{\Sigma}}

\newcommand{\FIRST}{\textsc{first}}
\newcommand{\FOLLOW}{\textsc{follow}}
\newcommand{\NEXT}{\textsc{next}}
\newcommand{\EOF}{\textsc{eof}}
\newcommand{\Terminals}{\Set{T}}
\newcommand{\Productions}{\Set{P}}
\newcommand{\NonTerminals}{\Set{N}}

\newcommand{\Arrow}{\Coloneq}
\newlength{\arrow}
\settowidth{\arrow}{\scriptsize$000$}
\newcommand{\MoveX}[1]{\xrightarrow{\mathmakebox[\arrow]{#1}}}
\newcommand{\Move}{\MoveX{}}
\newcommand{\MoveStar}{\nolinebreak\mathrel{\Move\!\!{}^\ast}\nolinebreak}
\newcommand{\Derive}{\Rightarrow}
\newcommand{\DeriveStar}{\Rightarrow^\ast}
\newcommand{\DerivePlus}{\Rigtharrow^+}

\newcommand{\NT}[1]{{#1}}
\newcommand{\T}[1]{{#1}}
\newcommand{\Var}[1]{{#1}}
\newcommand{\Sym}[1]{{#1}}
\newcommand{\RE}[1]{{\uppercase{#1}}}
\newcommand{\Lookahead}[1]{{}_{\{{#1}\}}}

\makeatletter
\DeclareRobustCommand{\Dots}{%
  \vbox{
    \baselineskip4\p@\lineskiplimit\z@
    \kern-\p@
    \hbox{.}\hbox{.}\hbox{.}
  }}
\makeatother

\lstnewenvironment{algorithm}[1][]
{
    \lstset{
        mathescape=true,
        %frame=tB,
        numbers=left, 
        %numberstyle=\tiny,
        basicstyle=\footnotesize, 
        %keywordstyle=\color{black}\bfseries\em,
        keywords={,input, output, return, datatype, function, in, if, else, foreach, while, begin, end, switch, case, default, when, }
        numbers=left,
        #1
    }
}
{}

\tikzset{
    cross/.pic = {
    \draw[rotate = 45] (-#1,0) -- (#1,0);
    \draw[rotate = 45] (0,-#1) -- (0, #1);
    },
    hide/.style={draw=none, fill=none},
    ellip/.append style={ellipse, inner sep=-0.14cm},
    every state/.append style={font=\footnotesize},
}

\begin{document}

\chapter{Končni avtomati}

\section{Jezik}
Jezik je (ne nujno končna) množica nizov.

\Ex
\begin{equation*}
  \Set{L} = \{\Str{}, \Str{DoberDan}, \Str{123}, \Str{/}, \Str{1 + 1} \}
\end{equation*}

\section{Regularni izrazi}
Regularni izrazi so algebra nad jeziki, ki sestavljena iz osnovnih operacij $(\Union)$, $(\Seq)$, $(\ast)$ in osnovnih elementov $\Char{a}$, $\Empty$, $\Null$.
Z njimi lahko opišemo le podmnožico vseh jezikov, ki se imenuje "regularni jeziki".
Dva regularna izraza sta enaka, če opisujeta enak jezik.



\section{Končni avtomati}

Končni avtomat je tuple $(\Set{Q}, \Alphabet, \delta, q_0, \Set{F})$, kjer je $\Set{Q}$ končna množica stanj, $\Alphabet$ končna množica znakov ali abeceda, $\delta$ je funkcija prehodov in $\Set{F}$ končna množica končnih stanj.
Tuple lahko implementiramo kot \emph{struct} ali \emph{record}.
Funkcija prehodov ima signaturo $\Set{Q} \times \Alphabet \not\rightarrow \Set{Q}$.
Implementiramo jo lahko, kot asociativni seznam, iskalno drevo ali tabelo.

\Special{Meta:} Avtomat regularnega izraza $\RE{r}$ bo označen kot $\Automaton{\RE{r}}$.

\Special{Meta:} Simbol $\Err$ označuje neveljavno stanje.

\Ex
\begin{equation*}
  \RE{r}_1 = \KleenePlus{(\Char{b} \Seq (\Char{a} \Seq \Char{b})?)} \Seq \Char{c} \\
\end{equation*}
\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.append style={minimum size=0.5cm},
      initial text=$ $
    }

    \node[state, initial, label=above left:$\Automaton{\RE{r}_1}$] (s0) {1};
    \node[state, right=of s0] (s1) {2};
    \node[state, accepting, right=of s1] (s2) {3};

    \draw (s0) edge[->, bend left] node[auto]{$\Char{b}$} (s1);
    \draw (s1) edge[->, bend left] node[auto]{$\Char{a}$} (s0);
    \draw (s1) edge[->, loop] node[above]{$\Char{b}$} (s1);
    \draw (s1) edge[->] node[auto]{$\Char{c}$} (s2);
  \end{tikzpicture}
\end{center}

\begin{align*}
  \Automaton{r_1} &= (\Set{Q}_1, \Alphabet, \delta_1, q_{0, 1}, \Set{F}_1)\\[1em]
  \Set{Q}_1 &= \{1, 2, 3\} \\[1em]
  \Alphabet &= \{\Char{a}, \Char{b}, \Char{c}\} \\[1em]
  \delta_1(1, \Char{b}) & =  2\\
  \delta_1(2, \Char{a}) & =  1\\
  \delta_1(2, \Char{b}) & =  2\\
  \delta_1(2, \Char{b}) & =  3\\[1em]
  q_{0, 1} &= 1 \\[1em]
  \Set{F}_1 &= \{3\}
\end{align*}

\begin{center}
\begin{tabular}{ | c | c | c | c | }
   \hline
   $\delta_1$ & \Char{a} & \Char{b} & \Char{c} \\
   \hline
  1 & $\Err$ & 2 & $\Err$  \\
   \hline
  2 & 1 & 2 & 3  \\
   \hline
  3 & $\Err$ & $\Err$ & $\Err$   \\
   \hline
\end{tabular}
\end{center}
\Ex

Vsak regularni izraz lahko ustreza večim različnim avtomatom.

\begin{gather*}
  \RE{r}_2 = \KleenePlus{(\Char{b} \Seq (\Char{a} \Seq \Char{b})?)} \Seq \Char{c} \\
  \Automaton{\RE{r}_2} = (\Set{Q}_2, \Alphabet, \delta_2, q_{0, 2}, \Set{F}_2)
\end{gather*}

\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.append style={minimum size=0.5cm},
      initial text=$ $
    }

    \node[state, initial, label=above left:$\Automaton{\RE{r}_2}$] (s0) {1};
    \node[state, right=of s0] (s1) {2};
    \node[state, right=of s1] (s2) {3};
    \node[state, right=of s2] (s3) {4};
    \node[state, accepting, below=0.4cm of s2] (s4) {5};

    \draw (s0) edge[->] node[auto]{$\Char{b}$} (s1);
    \draw (s1) edge[->, loop] node[above]{$\Char{b}$} (s1);
    \draw (s1) edge[->] node[auto]{$\Char{a}$} (s2);
    \draw (s2) edge[->] node[auto]{$\Char{b}$} (s3);
    \draw (s1) edge[->] node[auto]{$\Char{c}$} (s4);
    \draw (s3) edge[->] node[auto]{$\Char{c}$} (s4);
    \draw (s3) edge[->, bend right=40] node[above]{$\Char{b}$} (s1);
  \end{tikzpicture}
\end{center}

Funkcijo prehodov lahko definiramo tudi za niz:
\begin{align*} % XXX define empty string
  \Kleene{\delta}(q, \varepsilon) &= q\\
  \Kleene{\delta}(q, a \Seq w) &= \Kleene{\delta}(q', w) \text{, kjer } q' = \delta(q, a) \text{ in } q' \neq \Err
\end{align*}

\Ex
\begin{align*}
  \Kleene{\delta_1}(1, \Str{b}) &= 2 \\
  \Kleene{\delta_1}(1, \Str{ba}) &= 1 \\
  \Kleene{\delta_1}(1, \Str{bab}) &= 2 \\
  \Kleene{\delta_1}(1, \Str{bc}) &= 3 \\
  \Kleene{\delta_1}(1, \Str{babbc}) &= 3 \\
  \Kleene{\delta_1}(2, \Str{bbb}) &= 2 \\
  \Kleene{\delta_1}(2, \Str{abbc}) &= 3
\end{align*}

Jezik, ki ga avtomat opisuje:
\begin{equation*}
  \Set{L} = \{w \in \Kleene{\Sigma} \mid \Kleene{\delta}(q_0, w) \in \Set{F}\}
\end{equation*}

\Ex

\begin{align*}
  \Kleene{\delta_1}(1, \Str{bc}) &= 3 \\
  \Kleene{\delta_1}(1, \Str{bbc}) &= 3 \\
  \Kleene{\delta_1}(1, \Str{bbbc}) &= 3 \\
  \cdots \\
  \Kleene{\delta_1}(1, \Str{babc}) &= 3 \\
  \Kleene{\delta_1}(1, \Str{bababc}) &= 3 \\
  \ldots \\
  \Kleene{\delta_1}(1, \Str{babbc}) &= 3 \\
  \Kleene{\delta_1}(1, \Str{babbbc}) &= 3 \\
  \cdots \\
  \Kleene{\delta_1}(1, \Str{bababbc}) &= 3 \\
  \Kleene{\delta_1}(1, \Str{bababbbc}) &= 3 \\
  \cdots \\
\end{align*}

\begin{multline*}
  \Set{L} = \{ \Str{bc}, \Str{bbc}, \Str{bbbc}, \ldots, \Str{babc}, \Str{bababc}, \ldots,\\
  \Str{babbc},  \Str{babbbc}, \ldots, \Str{bababbc}, \Str{bababbbc}, \dots \}
\end{multline*}

%Za implementacijo pregledovalnika je potrebno končnemu avtomatu dodati funkcijo, ki končna stanja preslika v terminale:
%\begin{equation*}
%  \acc: Q \rightarrow T
%\end{equation*}

\section{Konstrukcija}

Za pretvorbo regularnih izrazov v avtomate bomo uporabili konstrukcijo na podlagi deloma razpoznanih regularnih izrazov.
Trenutne pozicije v takšnem regularnem izrazu bodo označene kot $\Pos$.

\Ex Pri $\Char{a} \Seq \Char{b} \Seq \Pos \Char{c} \Seq \Char{d}$ smo že razpoznali $\Str{ab}$ in pričakujemo še $\Str{cd}$.

Za izvedbo konstrukcije potrebujemo naslednje relacije nad deloma razponanimi regularnimi izrazi $(\Move)$, $(\MoveStar)$ in $(\MoveX{\Char{a}})$.
\begin{description}
  \item[$(\Move)$] so pravila za premik trenutnih pozicij v regularnem izrazu skozi operacije.
  \item[$(\MoveStar)$] je zaprtje $(\Move)$. To pomeni, da znova in znova apliciramo pravila $(\Move)$, doker je to mogoče.
  \item[$(\MoveX{\Char{a}})$] so pravila za premik trenutnih pozicij preko znaka $\Char{a}$.
\end{description}

\subsubsection*{Postopek}

Vhod je regularni izraz $\RE{r}$.

Izhod je automat $\Automaton{\RE{r}} = (\Set{Q}, \Set{\Sigma}, \delta, q_{0}, \Set{F})$, ker $\Language{\RE{r}} = \Language{\Automaton{R}}$.

\begin{enumerate}
  \item Začnemo z začetnim stanjem:
    \begin{equation*}
      q_0 = \RE{i}\text{, kjer } \Pos(\RE{r}) \MoveStar \RE{i}
    \end{equation*}
  \item Za vsak znak $\Char{a} \in \Alphabet$, iz trenutnega stanja $q = \RE{i}$ pridobimo stanja:
    \begin{equation*}
      q' = \RE{j}\text{, kjer } \RE{i} \MoveX{\Char{a}} \RE{i}' \MoveStar \RE{j}
    \end{equation*}
    Če že obstaja stanje $q'' = \RE{k}$, kjer $\RE{j} = \RE{k}$, potem $q'$ in $q''$ združimo.
  \item Za vsako stanje dodamo prehod $\delta(q, \Char{a}) = q'$.
  \item Postopek nadaljujemo za vsa tako nastala stanja, ki jih še nismo obravnavali.
  \item Stanje $q = \RE{i}$ je končno, če $\RE{i} = (\RE{r})\Pos$.
\end{enumerate}

\subsection{Prazen jezik}
\begin{tcolorbox}[title={Definicija}]
\begin{equation*}
  \begin{aligned}
    \RE{r} &= \Empty\\
    \Language{\RE{R}} &= \{\}
  \end{aligned}
\end{equation*}
\end{tcolorbox}

\begin{tcolorbox}[title={Konstrukcija}]
\begin{equation*}
  \begin{aligned}
    \Pos\Empty &\Move \Empty
  \end{aligned}
\end{equation*}
\end{tcolorbox}

\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
    }
    \node[state, initial, label=above left:$\Automaton{\RE{r}}$] (u0) {$\Empty$};
  \end{tikzpicture}
\end{center}

\subsection{Prazen niz}

\begin{tcolorbox}[title={Definicija}]
\begin{equation*}
  \begin{aligned}
    \RE{r} &= \Null\\
    \Language{\RE{r}} &= \{ \Str{} \}
  \end{aligned}
\end{equation*}
\end{tcolorbox}

\begin{tcolorbox}[title={Konstrukcija}]
\begin{equation*}
  \begin{aligned}
    \Pos\Null &\Move \Null\Pos
  \end{aligned}
\end{equation*}
\end{tcolorbox}

\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
    }
    \node[state, initial, accepting, label=above left:$\Automaton{\RE{r}}$] (u0) {$\Null\Pos$};
  \end{tikzpicture}
\end{center}

Če $\Str{} \in \Language{\RE{r}}$, potem rečemo, da je $\RE{r}$ \emph{nullable}.

\subsection{Znak}

\begin{tcolorbox}[title={Definicija}]
\begin{equation*}
  \begin{aligned}
    \RE{r} &= \Char{a}\text{, kjer } \Char{a} \in \Alphabet\\\
    \Language{\RE{r}} &= \{ \Str{a} \}
  \end{aligned}
\end{equation*}
\end{tcolorbox}

\begin{tcolorbox}[title={Konstrukcija}]
\begin{equation*}
  \begin{aligned}
    \Pos\Char{a} &\MoveX{\Char{a}} \Char{a}\Pos\\
    (\RE{R})\Pos &\MoveX{\Char{a}} \RE{R}\\
    \Pos\Char{a} &\MoveX{\Char{b}} \Char{a}\text{, kjer } \Char{a} \neq \Char{b}
  \end{aligned}
\end{equation*}
\end{tcolorbox}

\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
    }
    \node[state, initial, label=above left:$\Automaton{\RE{r}}$] (u0) {$\Pos\Char{a}$};
    \node[state, accepting, right=of u0] (u1) {$\Char{a}\Pos$};
    \draw (u0) edge[->] node[auto]{$\Char{a}$} (u1);
  \end{tikzpicture}
\end{center}

%\begin{equation*}
%  \begin{aligned}
%    \Pos\Set{S} &\MoveX{\Set{S}} \Set{S}\Pos\\
%    %(\RE{R})\Pos &\MoveX{\Char{a}} \RE{R}\\
%    \Pos\Set{S} &\MoveX{\Set{S}} \Set{S}
%  \end{aligned}
%\end{equation*}
%
%\begin{center}
%  \begin{tikzpicture}
%    \tikzset{
%      node distance=1cm,
%      every state/.style={rectangle, rounded corners, inner sep=0.5em},
%      initial text=$ $,
%    }
%    \node[state, initial, label=above left:$\Automaton{R}$] (u0) {$\Pos\Set{S}$};
%    \node[state, right=of u0] (u1) {$\Set{S}\Pos$};
%    \draw (u0) edge[->] node[auto]{$\Set{S}$} (u1);
%  \end{tikzpicture}
%\end{center}

\subsection{Konkatenacija}
\Reset

\begin{tcolorbox}[title={Definicija}]
\begin{equation*}
  \begin{aligned}
    \RE{r} &= \RE{s} \Seq \RE{t} = \RE{s} \Spc \RE{t}\\
    \Language{\RE{r}} &= \{ u \Seq v \mid u \in \Language{\RE{s}} \land v \in \Language{\RE{t}}\}
  \end{aligned}
\end{equation*}
\end{tcolorbox}

\begin{tcolorbox}[title={Pravila}]
\begin{equation*}
  \begin{aligned}
    \RE{s} \Seq \RE{t} &\not= \RE{t} \Seq \RE{s}\\
    \RE{s} \Seq \Null &= \RE{s} \\
    \Null \Seq \RE{s} &= \RE{s} \\
    \RE{s} \Seq \Empty &= \Empty \\
    \Empty \Seq \RE{s} &= \Empty \\
    (\RE{s} \Seq \RE{p}) \Seq \RE{q} &= \RE{s} \Seq (\RE{p} \Seq \RE{q}) = \RE{s} \Seq \RE{p} \Seq \RE{q}
  \end{aligned}
\end{equation*}
\end{tcolorbox}

\vspace{1em}
\Special{Poseben primer:} Če $|\Language{\RE{s}}| = |\Language{\RE{t}}| = 1$, potem $\Language{\RE{s}} = \{u\}$ in $\Language{\RE{t}} = \{v\}$ in $\Language{\RE{r}} = \{u \Seq v\}$.

\Ex
\begin{align*}
  \Language{\RE{s}} &= \{\Str{Hello}\}\\
  \Language{\RE{t}} &= \{\Str{World}\}\\
  \Language{\RE{r}} &= \{\Str{HelloWorld}\}
\end{align*}

Splošno je jezik konkatenacije podoben kartezičnemu produktu.
\begin{align*}
  \Set{S} &= \Set{P} \times \Set{Q} \\
  \Set{S} &= \{ (x, y) \mid x \in \Set{P} \land y \in \Set{Q}\}
\end{align*}

\Ex
\begin{align*}
  \Set{P} &= \{1, 2, 3\}\\
  \Set{Q} &= \{a, b\}\\
  \Set{S} &= \{(1, a), (1, b), (2, a), (2, b), (3, a), (3, b) \}
\end{align*}

Edina razlika je da zamenjamo vsak $(u, v)$, kjer $u \in \Language{\RE{s}}$ in $v\in \Language{\RE{t}}$, z $u \Seq v \in \Language{\RE{r}}$.

\Ex

\begin{align*}
  \RE{P} &= \{\Str{Dober}, \Str{Lep}\}\\
  \RE{Q} &= \{\Str{Dan}, \Str{Večer}, \Str{Tek}\}\\
  \RE{S} &= \{\Str{DoberDan}, \Str{DoberVečer}, \Str{DoberTek}, \Str{LepDan}, \Str{LepVečer}, \Str{LepTek} \}
\end{align*}

\begin{tcolorbox}[title={Konstrukcija}]
  \begin{equation*}
    \begin{aligned}
      \Pos(\RE{R} \Seq \RE{S}) &\Move (\Pos\RE{R}) \Seq \RE{S}\\
      (\RE{R}\Pos) \Seq \RE{S} &\Move \RE{R} \Seq (\Pos \RE{S})\\
      \RE{R} \Seq (\RE{S} \Pos) &\Move (\RE{R} \Seq \RE{S})\Pos
    \end{aligned}
  \end{equation*}
\end{tcolorbox}

\Ex
\begin{align*}
  \N{\RE{r}} &= \Char{a} \Spc \Char{b} \\
\end{align*}
\begin{multline*}
  \Pos(\Char{a} \Seq \Char{b}) \Move (\Pos\Char{a}) \Seq \Char{b} \MoveX{\Char{a}}
  (\Char{a}\Pos) \Seq \Char{b} \Move \Char{a} \Seq (\Pos\Char{b}) \MoveX{\Char{b}}
  \Char{a} \Seq (\Char{b}\Pos) \Move (\Char{a} \Seq \Char{b})\Pos
\end{multline*}
\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
    }

    \node[state, initial, label=above left:$\Automaton{\RE{r}}$] (u0) {$\Pos\Char{a} \Spc \Char{b}$};
    \node[state, right=of u0] (u1) {$\Char{a} \Pos \Char{b}$};
    \node[state, accepting, right=of u1] (u2) {$\Char{a} \Spc \Char{b}\Pos$};
    \draw (u0) edge[->] node[auto]{\Char{a}} (u1);
    \draw (u1) edge[->] node[auto]{\Char{b}} (u2);
  \end{tikzpicture}
\end{center}

\Ex
\begin{align*}
  \N{\RE{r}} &= \Char{a} \Spc \Char{b} \Spc \Char{c} \\
\end{align*}
\begin{multline*}
  \Pos((\Char{a} \Seq \Char{b}) \Seq \Char{c}) \Move
  (\Pos(\Char{a} \Seq \Char{b}) \Seq \Char{c}) \Move
  (((\Pos\Char{a}) \Seq \Char{b}) \Seq \Char{c}) \MoveX{\Char{a}}
  (((\Char{a}\Pos) \Seq \Char{b}) \Seq \Char{c}) \Move
  ((\Char{a} \Seq (\Pos \Char{b})) \Seq \Char{c}) \MoveX{\Char{b}}
  ((\Char{a} \Seq (\Char{b}\Pos)) \Seq \Char{c}) \Move\\
  ((\Char{a} \Seq \Char{b})\Pos \Seq \Char{c}) \Move
  ((\Char{a} \Seq \Char{b}) \Seq (\Pos \Char{c})) \MoveX{\Char{c}}
  ((\Char{a} \Seq \Char{b}) \Seq (\Char{c}\Pos)) \Move
  ((\Char{a} \Seq \Char{b}) \Seq \Char{c})\Pos
\end{multline*}
\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
    }

    \node[state, initial, label=above left:$\Automaton{\RE{r}}$] (u0) {$\Pos\Char{a} \Spc \Char{b} \Spc \Char{c}$};
    \node[state, right=of u0] (u1) {$\Char{a} \Pos \Char{b} \Spc \Char{c}$};
    \node[state, right=of u1] (u2) {$\Char{a} \Spc \Char{b} \Pos \Char{c}$};
    \node[state, accepting, right=of u2] (u3) {$\Char{a} \Spc \Char{b} \Spc \Char{c}\Pos$};
    \draw (u0) edge[->] node[auto]{\Char{a}} (u1);
    \draw (u1) edge[->] node[auto]{\Char{b}} (u2);
    \draw (u2) edge[->] node[auto]{\Char{c}} (u3);
  \end{tikzpicture}
\end{center}

\subsection*{Primeri}

\subsubsection{"then"}
\begin{equation*}
  \Language{\N{\RE{r}}} = \{ \Str{then} \}
\end{equation*}

\subsection{Unija}
\Reset

\begin{tcolorbox}[title={Definicija}]
  \begin{equation*}
    \begin{aligned}
      \RE{r} &= \RE{s} \Union \RE{t} \\
      \Language{\RE{r}} &= \Language{\RE{s}} \cup \Language{\RE{t}}
    \end{aligned}
  \end{equation*}
\end{tcolorbox}

\begin{tcolorbox}[title={Pravila}]
  \begin{equation*}
    \begin{aligned}
      \RE{s} \Union \RE{t} &= \RE{t} \Union \RE{s} \\
      \RE{s} \Union \RE{s} &= \RE{s} \\
      \Empty \Union \RE{s} &= \RE{s} \\
      \RE{s} \Union \Empty &= \RE{s} \\
      (\RE{s} \Union \RE{p}) \Union \RE{q} &= \RE{s} \Union (\RE{p} \Union \RE{q}) = \RE{s} \Union \RE{p} \Union \RE{q} \\
      \RE{s} \Seq (\RE{p} \Union \RE{q}) &= \RE{s} \Seq \RE{p} \Union \RE{s} \Seq \RE{q}\\
      (\RE{p} \Union \RE{q}) \Seq \RE{s} &= \RE{p} \Seq \RE{s} \Union \RE{q} \Seq \RE{s}\\
    \end{aligned}
  \end{equation*}
\end{tcolorbox}

\begin{tcolorbox}[title={Konstrukcija}]
\begin{equation*}
  \begin{aligned}
    \Pos(\RE{R} \Union \RE{S}) &\Move (\Pos\RE{R}) \Union (\Pos\RE{S})\\
    (\RE{R}\Pos) \Union \RE{S} &\Move (\RE{R} \Union \RE{S})\Pos\\
    \RE{R} \Union (\RE{S}\Pos) &\Move (\RE{R} \Union \RE{S})\Pos
  \end{aligned}
\end{equation*}
\end{tcolorbox}

\Ex
\begin{align*}
  \N{\RE{r}} &= \Char{a} \Union \Char{b} \\
\end{align*}
\begin{equation*}
  \Pos(\Char{a} \Union \Char{b}) \Move
  (\Pos\Char{a}) \Union (\Pos\Char{b}) \begin{aligned}[t]
    &\MoveX{\Char{a}} (\Char{a}\Pos) \Union \Char{b} \Move (\Char{a} \Union \Char{b})\Pos \\
    &\MoveX{\Char{b}} \Char{a} \Union (\Char{b}\Pos) \Move (\Char{a} \Union \Char{b})\Pos \\
  \end{aligned}
\end{equation*}
\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
      shorten <>/.style={shorten >=#1, shorten <=#1},
    }

    \node[state, initial, label=above left:$\Automaton{\N{\RE{r}}}$] (u0) {$\Pos\Char{a} \Union \Pos\Char{b}$};
    \node[state, accepting, above right=of u0, label={above right:=}] (u1) {$(\Char{a} \Union \Char{b})\Pos$};

    \draw (u0.north east) edge[->, shorten <>=-2pt+\pgflinewidth] node[auto]{$\Char{a}$} (u1.south west);

    \node[state, accepting, below right=of u0, label={above right:=}] (u4) {$(\Char{a} \Union \Char{b})\Pos$};

    \draw (u0.south east) edge[->, shorten <>=-2pt+\pgflinewidth] node[auto]{$\Char{b}$} (u4.north west);

    \node[state, initial, below=3.2of u0, label=above left:$\Automaton{\N{\RE{r}}}$] (p0) {$\Pos\Char{a} \Union \Pos\Char{b}$};
    \node[state, accepting, right=1.5cm of p0] (p1) {$(\Char{a} \Union \Char{b})\Pos$};

    \draw (p0.north east) edge[->, bend left=40, shorten <>=-2pt+\pgflinewidth] node[auto]{$\Char{a}$} (p1.north west);
    \draw (p0.south east) edge[->, bend right=40, shorten <>=-2pt+\pgflinewidth] node[below]{$\Char{b}$} (p1.south west);

  \end{tikzpicture}
\end{center}

\Ex
\begin{align*}
  \N{\RE{r}} &= \Char{a} \Union \Char{b} \Union \Char{c} \\
\end{align*}
\begin{equation*}
  \Pos((\Char{a} \Union \Char{b}) \Union \Char{c}) \Move
  (\Pos(\Char{a} \Union \Char{b})) \Union (\Pos\Char{c}) \Move
  ((\Pos\Char{a}) \Union (\Pos \Char{b})) \Union (\Pos\Char{c}) \begin{aligned}[t]
    & \MoveX{\Char{a}} ((\Char{a}\Pos) \Union \Char{b}) \Union \Char{c} \Move ((\Char{a} \Union \Char{b}) \Union \Char{c})\Pos \\
    & \MoveX{\Char{b}} (\Char{a} \Union (\Char{b} \Pos)) \Union \Char{c} \Move ((\Char{a} \Union \Char{b}) \Union \Char{c})\Pos \\
    & \MoveX{\Char{c}} (\Char{a} \Union \Char{b}) \Union (\Char{c} \Pos) \Move ((\Char{a} \Union \Char{b}) \Union \Char{c})\Pos 
  \end{aligned}
\end{equation*}

\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
      shorten <>/.style={shorten >=#1, shorten <=#1},
    }
    \node[state, initial, below=3.2of u0, label=above left:$\Automaton{\N{R}}$] (p0) {$\Pos\Char{a} \Union \Pos\Char{b} \Union \Pos\Char{c}$};
    \node[state, accepting, right=1.5cm of p0] (p1) {$(\Char{a} \Union \Char{b} \Union \Char{c})\Pos$};

    \draw (p0.north east) edge[->, bend left=40, shorten <>=-2pt+\pgflinewidth] node[auto]{$\Char{a}$} (p1.north west);
    \draw (p0.east) edge[->] node[above]{$\Char{b}$} (p1.west);
    \draw (p0.south east) edge[->, bend right=40, shorten <>=-2pt+\pgflinewidth] node[below]{$\Char{c}$} (p1.south west);
  \end{tikzpicture}
\end{center}

\Ex
\begin{equation*}
  \N{\RE{r}} = \Char{a} \Spc \Char{b} \Union \Char{a} \Spc \Char{b} \Spc \Char{c} \Union \Char{a} \Spc \Char{c} \Spc \Char{d}
\end{equation*}

\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      %every state/.append style={minimum size=0.5cm},
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
      large/.style={minimum size=1.5cm},
    }

    \node[state, initial, label=above left:$\Automaton{\RE{r}}$] (u0) {$\Pos\Char{a} \Spc \Char{b} \Union \Pos\Char{a}\Spc\Char{b}\Spc\Char{c} \Union \Pos\Char{a}\Spc\Char{c}\Spc\Char{d}$};
    \node[state, right=of u0] (u1) {$\Char{a} \Pos\Char{b} \Union \Char{a}\Pos\Char{b}\Spc\Char{c} \Union \Char{a}\Pos\Char{c}\Spc\Char{d}$};
    \node[state, accepting, right=of u1] (u2) {$(\Char{a} \Spc\Char{b} \Union \Char{a}\Spc\Char{b}\Pos\Char{c} \Union \Char{a}\Spc\Char{c}\Spc\Char{d})\Pos$};
    \draw (u0) edge[->] node[auto]{$\Char{a}$} (u1);
    \draw (u1) edge[->] node[auto]{$\Char{b}$} (u2);

    \node[state, below=of u1] (u4) {$\Char{a} \Spc\Char{b} \Union \Char{a}\Spc\Char{b}\Spc\Char{c} \Union \Char{a}\Spc\Char{c}\Pos\Char{d}$};
    \node[state, accepting, below=of u2] (u3) {$(\Char{a} \Spc\Char{b} \Union \Char{a}\Spc\Char{b}\Spc\Char{c} \Union \Char{a}\Spc\Char{c}\Spc\Char{d})\Pos$};

    \draw (u2) edge[->] node[auto]{$\Char{c}$} (u3);
    \draw (u1) edge[->] node[auto]{$\Char{c}$} (u4);
    \draw (u4) edge[->] node[auto]{$\Char{d}$} (u3);
  \end{tikzpicture}
\end{center}

Avtomat je optimalen.
Ne vemo za katero ključno besedo smo našli ujemanje.

\subsection*{Leva faktorizacija}
Skupno predpono izpostavimo.

\Ex
\begin{align*}
  \N{\RE{r}} &= \Char{a} \Spc \Char{b} \Union \Char{a} \Spc \Char{b} \Spc \Char{c} \Union \Char{a} \Spc \Char{c} \Spc \Char{d}\\
        &= \Char{a} \Seq (\Char{b} \Union \Char{b} \Spc \Char{c} \Union \Char{c} \Spc \Char{d})\\
        &= \Char{a} \Seq (\Char{b} \Seq (\Null \Union \Char{c}) \Union \Char{c} \Spc \Char{d})
\end{align*}

\subsection*{Primeri}
\subsubsection{Ključne besede}

\begin{equation*}
  \N{\RE{r}} = \Char{i} \Spc \Char{f} \Union \Char{f} \Spc \Char{o} \Spc \Char{r} \Union \Char{f} \Spc \Char{o} \Spc \Char{r} \Spc \Char{e} \Spc \Char{a} \Spc \Char{c} \Spc \Char{h}
\end{equation*}

\subsection{Regularne definicije}

\begin{align*}
  \N{\RE{p}} &= \Char{a} \Spc \Char{b}\\
  \N{\RE{q}} &= \Char{a} \Spc \Char{b} \Spc \Char{c}\\
  \N{\RE{t}} &= \Char{a} \Spc \Char{c} \Spc \Char{d}
\end{align*}

\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      %every state/.append style={minimum size=0.5cm},
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
      large/.style={minimum size=1.5cm},
    }

    \node[state, initial, label=above left:$\Automaton{\RE{r}, \RE{p}, \RE{q}}$] (u0) {$\begin{aligned}
      \N{\RE{r}} &= \Pos\Char{a} \Spc \Char{b}\\
      \N{\RE{p}} &= \Pos\Char{a} \Spc \Char{b} \Spc \Char{c}\\
      \N{\RE{q}} &= \Pos\Char{a} \Spc \Char{c} \Spc \Char{d}
    \end{aligned}$};
    \node[state, right=of u0] (u1) {$\begin{aligned}
      \N{\RE{r}} &= \Char{a} \Pos \Char{b}\\
      \N{\RE{p}} &= \Char{a} \Pos \Char{b} \Spc \Char{c}\\
      \N{\RE{q}} &= \Char{a} \Pos \Char{c} \Spc \Char{d}
    \end{aligned}$};
    \node[state, accepting, right=of u1] (u2) {$\begin{aligned}
      \underline{\N{\RE{r}}} &= \Char{a} \Spc \Char{b}\Pos\\
      \N{\RE{p}} &= \Char{a} \Spc \Char{b} \Pos \Char{c}\\
      \N{\RE{q}} &= \Char{a} \Spc \Char{c} \Spc \Char{d}
    \end{aligned}$};
    \node[state, accepting, right=of u2] (u5) {$\begin{aligned}
      \N{\RE{r}} &= \Char{a} \Spc \Char{b}\\
      \underline{\N{\RE{p}}} &= \Char{a} \Spc \Char{b} \Spc \Char{c}\Pos\\
      \N{\RE{q}} &= \Char{a} \Spc \Char{c} \Spc \Char{d}
    \end{aligned}$};

    \draw (u0) edge[->] node[auto]{$\Char{a}$} (u1);
    \draw (u1) edge[->] node[auto]{$\Char{b}$} (u2);
    \draw (u2) edge[->] node[auto]{$\Char{b}$} (u5);

    \node[state, below=of u1] (u4) {$\begin{aligned}
      \N{\RE{r}} &= \Char{a} \Spc \Char{b}\\
      \N{\RE{p}} &= \Char{a} \Spc \Char{b} \Spc \Char{c}\\
      \N{\RE{q}} &= \Char{a} \Spc \Char{c} \Pos \Char{d}
    \end{aligned}$};

    \node[state, accepting, below=of u2] (u3) {$\begin{aligned}
      \N{\RE{r}} &= \Char{a} \Spc \Char{b}\\
      \N{\RE{p}} &= \Char{a} \Spc \Char{b} \Spc \Char{c}\\
      \underline{\N{\RE{q}}} &= \Char{a} \Spc \Char{c} \Spc \Char{d} \Pos
    \end{aligned}$};

    \draw (u1) edge[->] node[auto]{$\Char{c}$} (u4);
    \draw (u4) edge[->] node[auto]{$\Char{d}$} (u3);
  \end{tikzpicture}
\end{center}

Nastali avtomat je drevo predpon.

\subsection*{Primeri}
\subsubsection{Ključne besede}

\begin{align*}
  \N{\RE{p}} &= \Char{i} \Spc \Char{f} \\
  \N{\RE{q}} &= \Char{f} \Spc \Char{o} \Spc \Char{r} \\
  \N{\RE{t}} &= \Char{f} \Spc \Char{o} \Spc \Char{r} \Spc \Char{e} \Spc \Char{a} \Spc \Char{c} \Spc \Char{h} \\
\end{align*}

\subsection{Množica znakov}
\Reset

\begin{tcolorbox}[title={Definicija}]
\begin{equation*}
  \begin{aligned}
    R &= \Set{S}\text{, kjer } \Set{S} \subseteq \Alphabet \\
    &= \Char{a} \Union \dots \Union \Char{b}\text{, kjer } \Char{a}, \dots, \Char{b} \in \Set{S}\\
    \Language{\RE{r}} &= \Set{S}
  \end{aligned}
\end{equation*}
\end{tcolorbox}

Množica znakov se lahko predstavi kot šop prehodov (eden za vsak znak) ali pa en sam prehod označen z množico.

\Ex
\begin{align*}
  \N{\RE{r}} &= \Char{a} \Union \Char{b} = \{\Char{a}, \Char{b}\} \\
\end{align*}
\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
      shorten <>/.style={shorten >=#1, shorten <=#1},
    }

    \node[state, initial, label=above left:$\Automaton{\N{\RE{r}}}$] (p0) {$\Pos\Char{a} \Union \Pos\Char{b}$};
    \node[state, accepting, right=1.5cm of p0] (p1) {$(\Char{a} \Union \Char{b})\Pos$};

    \draw (p0.north east) edge[->, bend left=40, shorten <>=-2pt+\pgflinewidth] node[auto]{$\Char{a}$} (p1.north west);
    \draw (p0.south east) edge[->, bend right=40, shorten <>=-2pt+\pgflinewidth] node[below]{$\Char{b}$} (p1.south west);

    \node[state, initial, below=2of p0, label=above left:$\Automaton{\N{\RE{r}}}$] (q0) {$\Pos\Char{a} \Union \Pos\Char{b}$};
    \node[state, accepting, right=2.5cm of q0] (q1) {$(\Char{a} \Union \Char{b})\Pos$};

    \draw (q0) edge[->] node[auto]{$\{\Char{a}, \Char{b}\}$} (q1);

    \node[state, initial, below=2of q0, label=above left:$\Automaton{\N{\RE{r}}}$] (t0) {$\{\Pos\Char{a}, \Pos\Char{b}\}$};
    \node[state, accepting, right=2.5cm of t0] (t1) {$\{\Char{a}, \Char{b}\}\Pos$};

    \draw (t0) edge[->] node[auto]{$\{\Char{a}, \Char{b}\}$} (t1);
  \end{tikzpicture}
\end{center}

\Ex
\begin{align*}
  \N{\RE{r}} &= \{\Char{a}, \Char{b}\}\\
  \N{\RE{s}} &= \{\Char{b}, \Char{c}, \Char{d}\}
\end{align*}

\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
      shorten <>/.style={shorten >=#1, shorten <=#1},
    }

    \node[state, initial, below=2of q0, label=above left:$\Automaton{\N{\RE{r}}, \N{\RE{s}}}$] (t0) {$\begin{aligned}\RE{r} &= \{\Pos\Char{a}, \Pos\Char{b}\}\\ \RE{s} &= \{\Pos\Char{b}, \Pos\Char{c}, \Pos\Char{d}\}\end{aligned}$};
    \node[state, accepting, above right=2.5cm of t0] (t1) {$\begin{aligned}\RE{r} &= \{\Char{a}, \Char{b}\}\Pos\\ \RE{s} &= \{\Char{b}, \Char{c}, \Char{d}\}\end{aligned}$};
    \node[state, accepting, right=2.5cm of t0] (t2) {$\begin{aligned}\RE{r} &= \{\Char{a}, \Char{b}\}\Pos\\ \RE{s} &= \{\Char{b}, \Char{c}, \Char{d}\}\Pos\end{aligned}$};
    \node[state, accepting, below right=2.5cm of t0] (t3) {$\begin{aligned}\RE{r} &= \{\Char{a}, \Char{b}\}\\ \RE{s} &= \{\Char{b}, \Char{c}, \Char{d}\}\Pos\end{aligned}$};

    \draw (t0.north east) edge[->, shorten <>=-2pt+\pgflinewidth] node[auto]{$\{\Char{a}\}$} (t1.south west);
    \draw (t0) edge[->] node[auto]{$\{\Char{b}\}$} (t2);
    \draw (t0.south east) edge[->, shorten <>=-2pt+\pgflinewidth] node[auto]{$\{\Char{c}, \Char{d}\}$} (t3.north west);
  \end{tikzpicture}
\end{center}
Paziti moramo, da avtomat ne postane nedeterminističen.

\subsection*{Primeri}

\subsubsection{Y/N}

\begin{equation*}
  \Language{\N{\RE{r}}} = \{ \Str{Y}, \Str{N} \}
\end{equation*}

\begin{equation*}
  \N{\RE{r}} = \{ \Char{Y}, \Char{N} \}
\end{equation*}

\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
      shorten <>/.style={shorten >=#1, shorten <=#1},
    }

    \node[state, initial, label=above left:$\Automaton{\N{\RE{r}}}$] (p0) {$\{ \Pos\Char{Y}, \Pos\Char{N} \}$};
    \node[state, accepting, right=1.5cm of p0] (p1) {$\{ \Char{Y}, \Char{N} \}\Pos$};

    \node[state, initial, below=of p0, label=above left:$\Automaton{\N{\RE{r}}}$] (q0) {$\{ \Pos\Char{Y}, \Pos\Char{N} \}$};
    \node[state, accepting, right=2.5cm of q0] (q1) {$\{ \Char{Y}, \Char{N} \}\Pos$};


    \draw (q0) edge[->] node[auto]{$\{\Char{Y}, \Char{N} \} $} (q1);

    \draw (p0.north east) edge[->, bend left=40, shorten <>=-2pt+\pgflinewidth] node[auto]{$\Char{Y}$} (p1.north west);
    \draw (p0.south east) edge[->, bend right=40, shorten <>=-2pt+\pgflinewidth] node[below]{$\Char{N}$} (p1.south west);
  \end{tikzpicture}
\end{center}
\Next

\subsubsection{Števke}

\begin{equation*}
  \Language{\N{\RE{r}}} = \{ \Str{0}, \Str{1}, \Str{2}, \dots, \Str{9} \}
\end{equation*}

\begin{equation*}
  \N{\RE{r}} = \{ \Char{0}, \Char{1}, \Char{2}, \dots, \Char{9} \}
\end{equation*}

\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
      shorten <>/.style={shorten >=#1, shorten <=#1},
    }

    \node[state, initial, label=above left:$\Automaton{\N{\RE{r}}}$] (p0) {$\{ \Pos\Char{0}, \Pos\Char{1}, \Pos\Char{2}, \dots, \Pos\Char{9} \}$};
    \node[state, accepting, right=1.5cm of p0] (p1) {$\{ \Char{0}, \Char{1}, \Char{2}, \dots, \Char{9} \}\Pos$};
    \node at ($(p0.east)!0.5!(p1.west)$) {\Dots{}};

    \node[state, initial, below=2of p0, label=above left:$\Automaton{\N{\RE{r}}}$] (q0) {$\{ \Pos\Char{0}, \Pos\Char{1}, \Pos\Char{2}, \dots, \Pos\Char{9} \}$};
    \node[state, accepting, right=2.5cm of q0] (q1) {$\{ \Char{0}, \Char{1}, \Char{2}, \dots, \Char{9} \} \Pos$};


    \draw (q0) edge[->] node[auto]{$\{\Char{0}, \Char{1}, \Char{2}, \ldots, \Char{9} \} $} (q1);

    \draw (p0.north east) edge[->, bend left=40, shorten <>=-2pt+\pgflinewidth] node[auto]{$\Char{0}$} (p1.north west);
    \draw (p0.south east) edge[->, bend right=40, shorten <>=-2pt+\pgflinewidth] node[below]{$\Char{9}$} (p1.south west);
  \end{tikzpicture}
\end{center}
\Next

\subsubsection{Male črke}

\begin{equation*}
  \Language{\N{\RE{r}}} = \{ \Str{a}, \Str{b}, \Str{c}, \dots, \Str{z} \}
\end{equation*}
\Next

\subsubsection{Velike in male črke}

\begin{equation*}
  \Language{\N{\RE{r}}} = \{ \Str{A}, \Str{B}, \Str{C}, \dots, \Str{Z}, \Str{a}, \Str{b}, \Str{c}, \dots, \Str{z} \}
\end{equation*}
\Next

\subsubsection{Heksadecimalne števke}


\begin{equation*}
  \Language{\N{\RE{r}}} = \{ \Str{0}, \Str{1}, \Str{2}, \dots, \Str{9}, \Str{A}, \dots, \Str{F} \}
\end{equation*}

\subsubsection{"then", "Then", "THEN", "theN", ...}
\begin{equation*}
  \N{\RE{r}} = \{\Char{T}, \Char{t}\} \Seq \{\Char{H}, \Char{h}\} \Seq \{\Char{E}, \Char{e}\} \Seq \{\Char{N}, \Char{n}\}
\end{equation*}

\Next
\subsubsection{Bajt po osmiško}

\begin{equation*}
  \N{\RE{r}} = \{\Char{0}, \dots, \Char{3}\} \Seq \{\Char{0}, \dots, \Char{7}\} \Seq \{\Char{0}, \dots, \Char{7}\}
\end{equation*}

\begin{equation*}
  \Language{\N{\RE{r}}} = \{ \Str{000}, \Str{001}, \Str{002}, \dots, \Str{377} \}
\end{equation*}
\Next

\subsection{Opcija}
\Reset

\begin{tcolorbox}[title={Definicija}]
  \begin{equation*}
    \begin{aligned}
      \Opt{\RE{s}} &= \Null \Union \RE{s}\\
      \Language{\Opt{\RE{s}}} &= \{\Str{}\} \cup \Language{\RE{s}}
    \end{aligned}
  \end{equation*}
\end{tcolorbox}

Ujemanje $S$ 0 ali 1 krat.

\begin{tcolorbox}[title={Konstrukcija}]
\begin{equation*}
  \begin{aligned}
    \Pos(\Opt{\RE{R}}) &\Move (\Opt{(\Pos\RE{R})})\Pos\\
    \Opt{(\RE{R}\Pos)} &\Move (\Opt{\RE{R}})\Pos
  \end{aligned}
\end{equation*}
\end{tcolorbox}

\Ex
\begin{align*}
  \N{\RE{s}} &= \Char{a}\\
  \N{\RE{r}} &= \Opt{\Char{a}}
\end{align*}
\begin{align*}
  \Language{\N{\RE{s}}} &= \{ \Str{a} \}\\
  \Language{\N{\RE{r}}} &= \{ \Str{}, \Str{a} \}
\end{align*}

\begin{equation*}
  \Pos(\Opt{\Char{a}}) \Move
  (\Opt{(\Pos\Char{a})})\Pos \MoveX{\Char{a}}
  \Opt{(\Char{a}\Pos)} \Move
  (\Opt{\Char{a}})\Pos
\end{equation*}
\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
    }
    \node[state, initial, accepting, label=above left:$\Automaton{R}$] (u0) {$\Opt{(\Pos\Char{a})}\Pos$};
    \node[state, accepting, right=of u0] (u1) {$\Opt{\Char{a}}\Pos$};
    \draw (u0) edge[->] node[auto]{$\Char{a}$} (u1);
  \end{tikzpicture}
\end{center}

\Ex
\begin{align*}
  \N{\RE{s}} &= \Char{a} \Seq \Char{b}\\
  \N{\RE{r}} &= \Opt{(\Char{a} \Seq \Char{b})}
\end{align*}
\begin{align*}
  \Language{\N{\RE{s}}} &= \{\Str{ab}\} \\
  \Language{\N{\RE{r}}} &= \{\Str{}, \Str{ab}\}
\end{align*}
\begin{multline*}
  \Pos(\Opt{(\Char{a} \Seq \Char{b})}) \Move
  (\Opt{\Pos(\Char{a} \Seq \Char{b})})\Pos \Move
  (\Opt{((\Pos\Char{a}) \Seq \Char{b})})\Pos \MoveX{\Char{a}}
  \Opt{((\Char{a}\Pos) \Seq \Char{b})} \Move\\
  \Opt{(\Char{a} \Seq (\Pos\Char{b}))} \MoveX{\Char{b}}
  \Opt{(\Char{a} \Seq (\Char{b}\Pos))} \Move
  \Opt{((\Char{a} \Seq \Char{b})\Pos)} \Move
  (\Opt{(\Char{a} \Seq \Char{b})})\Pos
\end{multline*}
\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
    }
    \node[state, initial, accepting, label=above left:$\Automaton{R}$] (u0) {$\Opt{(\Pos\Char{a} \Spc \Char{b})}\Pos$};
    \node[state, right=of u0] (u1) {$\Opt{(\Char{a} \Pos \Char{b})}$};
    \node[state, accepting, right=of u1] (u2) {$\Opt{(\Char{a} \Spc \Char{b})}\Pos$};
    \draw (u0) edge[->] node[auto]{$\Char{a}$} (u1);
    \draw (u1) edge[->] node[auto]{$\Char{b}$} (u2);
  \end{tikzpicture}
\end{center}

\subsection{Potence}
\Reset

\begin{tcolorbox}[title={Definicija}]
\begin{equation*}
  \begin{aligned}
    \Rep{\RE{s}}{0} &= \Null\\
    \Rep{\RE{s}}{i+1} &= \Rep{\RE{s}}{i} \Seq \RE{s}\\[1em]
    \Rep{\RE{s}}{i} &= \underbrace{\RE{s} \Seq \ldots \Seq \RE{s}}_{i}\\[1em]
    \Language{\Rep{\RE{s}}{0}} &= \Null\\
    \Language{\Rep{\RE{s}}{i+1}} &= \{u \Seq v \mid u \in \Language{\Rep{\RE{s}}{i}} \land v \in \Language{\RE{s}}\}
  \end{aligned}
\end{equation*}
\end{tcolorbox}
\begin{align*}
\end{align*}

%\begin{tcolorbox}[title={Konstrukcija}]
%\begin{equation*}
%  \begin{aligned}
%    \Pos(\Rep{\RE{R}}{n}) &\Move \Rep{(\Pos\RE{R})}{n}\\
%    \Rep{(\RE{R}\Pos)}{n} &\Move \Rep{(\Pos\RE{R})}{n-1}\\
%    \Rep{(\Pos\RE{R})}{0} &\Move (\Rep{\RE{R}}{0})\Pos
%  \end{aligned}
%\end{equation*}
%\end{tcolorbox}

\Ex
\begin{align*}
  \N{\RE{s}} &= \Char{a}\\
  \N{\RE{r}} &= \Rep{\Char{a}}{2} = \Char{a} \Seq \Char{a}
\end{align*}

\begin{align*}
  \Language{\N{\RE{s}}} &= \{ \Str{a} \}\\
  \Language{\N{\RE{r}}} &= \{ \Str{aa} \}
\end{align*}

\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
    }
    \node[state, initial, label=above left:$\Automaton{R}$] (u0) {$\Pos\Char{a} \Spc \Char{a}$};
    \node[state, right=of u0] (u1) {$\Char{a} \Pos \Char{a}$};
    \node[state, accepting, right=of u1] (u2) {$\Char{a} \Spc \Char{a}\Pos$};
    \draw (u0) edge[->] node[auto]{$\Char{a}$} (u1);
    \draw (u1) edge[->] node[auto]{$\Char{a}$} (u2);
  \end{tikzpicture}
\end{center}

\subsection*{Primeri}

\subsubsection{"aaaa"}

\begin{align*}
  \N{\RE{s}} &= \Char{a} \\
  \N{\RE{r}} &= \Char{a}^4
\end{align*}
\begin{align*}
  \Language{\N{\RE{s}}} &= \{\Str{a}\} \\
  \Language{\N{\RE{r}}} &= \{\Str{aaaa}\}
\end{align*}
\Next

\subsubsection{"abab"}

\begin{align*}
  \N{\RE{s}} &= \Char{a} \Spc \Char{b} \\
  \N{\RE{r}} &= (\Char{a} \Spc \Char{b})^2
\end{align*}
\begin{align*}
  \Language{\N{\RE{s}}} &= \{\Str{ab}\} \\
  \Language{\N{\RE{r}}} &= \{\Str{abab}\}
\end{align*}
\Next

\subsubsection{Bajt po osmiško}
\begin{equation*}
  \N{\RE{r}} = \{\Char{0}, \dots, \Char{3}\} \Seq (\{\Char{0}, \dots, \Char{7}\})^2
\end{equation*}
\Next

\subsection{Kleene-ovo zaprtje}
\Reset

\begin{tcolorbox}[title={Definicija}]
  \begin{equation*}
    \begin{aligned}
      \Kleene{\RE{s}} &= \Null \Union \RE{s} \Union \RE{s} \Seq \RE{s} \Union \RE{s} \Seq \RE{s} \Seq \RE{s} \Union \ldots \\
      &= \Rep{\RE{s}}{0} \Union \Rep{\RE{s}}{1} \Union \Rep{\RE{s}}{2} \Union \ldots \\
      &= \Big\vert_{i = 0}^\infty \Rep{\RE{s}}{i}\\
      \Language{\Kleene{\RE{s}}} &= \bigcup_{i = 0}^\infty \Language{\RE{s}^i}
    \end{aligned}
  \end{equation*}
\end{tcolorbox}

Ujemanje $s$ 0 ali več krat.
Z drugimi besedami, $s$ je lahko ponovljen $0, 1, 2, \dots, \infty$ krat.

\begin{tcolorbox}[title={Pravila}]
  \begin{equation*}
    \begin{aligned}
      \Kleene{\Empty} &= \Null\\
      \Kleene{\Null} &= \Null\\
      \Null \Union \Kleene{\RE{s}} &= \Kleene{\RE{s}}\\
      \Kleene{\RE{s}} \Union \Null &= \Kleene{\RE{s}}\\
      \Kleene{(\Kleene{\RE{s}})} &= \Kleene{\RE{s}}\\
      \Kleene{(\RE{s} \Union \RE{t})} &= \Kleene{(\Kleene{\RE{s}} \Seq \RE{t})} \Seq \Kleene{\RE{s}}\\
      \Kleene{(\RE{s} \Seq \RE{t})} &= \Null \Union \RE{s} \Seq \Kleene{(\RE{t} \Seq \RE{s})} \Seq \RE{t}\\
      \Kleene{\RE{s}} &= (\Null \Union \RE{s} \Union ... \Union \Rep{\RE{s}}{i - 1}) \Seq \Kleene{(\Rep{\RE{s}}{i})}
    \end{aligned}
  \end{equation*}
\end{tcolorbox}

\begin{tcolorbox}[title={Konstrukcija}]
\begin{equation*}
  \begin{aligned}
    \Pos(\Kleene{\RE{R}}) &\Move (\Kleene{(\Pos\RE{R})})\Pos\\
    \Kleene{(\RE{R}\Pos)} &\Move (\Kleene{(\Pos\RE{R})})\Pos
  \end{aligned}
\end{equation*}
\end{tcolorbox}

\Ex
\begin{align*}
  \N{\RE{s}} &= \Char{a}\\
  \N{\RE{r}} &= \Kleene{\Char{a}}
\end{align*}

\begin{align*}
  \Language{\N{\RE{s}}} &= \{\Str{a}\}\\
  \Language{\N{\RE{r}}} &= \{\Str{}, \Str{a}, \Str{aa}, \Str{aaa}, \dots\}
\end{align*}

\begin{equation*}
  \Pos(\Kleene{\Char{a}}) \Move
  (\Kleene{(\Pos\Char{a})})\Pos \MoveX{\Char{a}}
  \Kleene{(\Char{a}\Pos)} \Move
  (\Kleene{(\Pos\Char{a})})\Pos \MoveX{\Char{a}} \cdots
\end{equation*}
\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
    }
    \node[state, initial, accepting, label=above left:$\Automaton{\RE{r}}$, label={above right:=}] (u0) {$\Kleene{(\Pos\Char{a})}\Pos$};
    \node[state, accepting, right=of u0, label={above right:=}] (u1) {$\Kleene{(\Pos\Char{a})}\Pos$};
    \draw (u0) edge[->] node[auto]{$\Char{a}$} (u1);

    \node[state, initial, below=of u0, accepting, label=above left:$\Automaton{\RE{r}}$] (p0) {$\Kleene{(\Pos\Char{a})}\Pos$};
    \draw (p0) edge[->, loop right] node[auto]{$\Char{a}$} (p0);
  \end{tikzpicture}
\end{center}

\Ex
\begin{align*}
  \N{\RE{s}} &= \Char{a} \Spc \Char{b} \\
  \N{\RE{r}} &= \Kleene{(\Char{a} \Spc \Char{b})}
\end{align*}

\begin{align*}
  \Language{\N{\RE{s}}} &= \{\Str{ab}\} \\
  \Language{\N{\RE{r}}} &= \{\Str{}, \Str{ab}, \Str{abab}, \Str{ababab}, \dots\}
\end{align*}

\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
      shorten <>/.style={shorten >=#1, shorten <=#1},
    }
    \node[state, initial, accepting, label=above left:$\Automaton{\RE{r}}$, label={above right:=}] (u0) {$\Kleene{(\Pos\Char{a}\Spc\Char{b})}\Pos$};
    \node[state, right=of u0] (u1) {$\Kleene{(\Char{a}\Pos\Char{b})}$};
    \node[state, accepting, right=of u1, label={above right:=}] (u2) {$\Kleene{(\Pos\Char{a}\Spc\Char{b})}\Pos$};
    \draw (u0) edge[->] node[auto]{$\Char{a}$} (u1);
    \draw (u1) edge[->] node[auto]{$\Char{b}$} (u2);

    \node[state, initial, accepting, below=2 of u0, label=above left:$\Automaton{\RE{r}}$] (p0) {$\Kleene{(\Pos\Char{a}\Spc\Char{b})}\Pos$};
    \node[state, right=of p0] (p1) {$\Kleene{(\Char{a}\Pos\Char{b})}$};
    \draw (p0.north east) edge[->, bend left, shorten <>=-2pt+\pgflinewidth] node[auto]{$\Char{a}$} (p1.north west);
    \draw (p1.south west) edge[->, bend left, shorten <>=-2pt+\pgflinewidth] node[auto]{$\Char{b}$} (p0.south east);
  \end{tikzpicture}
\end{center}

\Ex

\begin{equation*}
  \N{\RE{r}} = \Char{c} \Spc \Kleene{(\Char{a} \Spc \Char{b})}
\end{equation*}

\begin{equation*}
  \Language{\N{\RE{r}}} = \{\Str{c}, \Str{cab}, \Str{cabab}, \Str{cababab}, \dots\}
\end{equation*}

\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
      shorten <>/.style={shorten >=#1, shorten <=#1},
    }
    \node[state, initial, label=above left:$\Automaton{\RE{r}}$] (u0) {$\Pos\Char{c} \Spc \Kleene{(\Char{a} \Spc \Char{b})}$};
    \node[state, initial, accepting, right=of u0, label={above right:=}] (u1) {$\Char{c} \Spc \Kleene{(\Pos\Char{a} \Spc \Char{b})}\Pos$};
    \node[state, right=of u1] (u2) {$\Char{c} \Spc \Kleene{(\Char{a} \Pos \Char{b})}$};
    \node[state, accepting, right=of u2, label={above right:=}] (u3) {$\Char{c} \Spc \Kleene{(\Pos\Char{a} \Spc \Char{b})}\Pos$};
    \draw (u0) edge[->] node[auto]{$\Char{c}$} (u1);
    \draw (u1) edge[->] node[auto]{$\Char{a}$} (u2);
    \draw (u2) edge[->] node[auto]{$\Char{b}$} (u3);

    \node[state, initial, below=2 of u0, label=above left:$\Automaton{\RE{r}}$] (p0) {$\Pos\Char{c} \Spc \Kleene{(\Char{a}\Spc\Char{b})}$};
    \node[state, accepting, right=of p0] (p1) {$\Char{c} \Spc \Kleene{(\Pos\Char{a}\Spc\Char{b})}$};
    \node[state, right=of p1] (p2) {$\Char{c} \Spc \Kleene{(\Char{a}\Pos\Char{b})}$};
    \draw (p0) edge[->] node[auto]{$\Char{c}$} (p1);
    \draw (p1.north east) edge[->, bend left, shorten <>=-2pt+\pgflinewidth] node[auto]{$\Char{a}$} (p2.north west);
    \draw (p2.south west) edge[->, bend left, shorten <>=-2pt+\pgflinewidth] node[auto]{$\Char{b}$} (p1.south east);
  \end{tikzpicture}
\end{center}
\Next

\Ex
\begin{equation*}
  \N{\RE{r}} = \Kleene{(\Char{a} \Spc \Char{a} \Union \Char{b})}
\end{equation*}

\begin{equation*}
  \Language{\N{\RE{r}}} = \{\Null, \Str{b}, \Str{aa}, \Str{bb}, \Str{aab}, \Str{baa}, \Str{aaaa}, \dots\}
\end{equation*}

\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
      shorten <>/.style={shorten >=#1, shorten <=#1},
    }
    \node[state, initial, accepting, label=above left:$\Automaton{\RE{r}}$, label={above right:=}] (u0) {$\Kleene{(\Pos\Char{a} \Spc \Char{a} \Union \Pos\Char{b})}\Pos$};
    \node[state, initial, right=of u0] (u1) {$\Kleene{(\Char{a} \Pos \Char{a} \Union \Char{b})}$};
    \node[state, right=of u1, accepting, label={above right:=}] (u2) {$\Kleene{(\Pos \Char{a} \Spc \Char{a} \Union \Pos\Char{b})}\Pos$};
    \node[state, accepting, below=of u1, label={above right:=}] (u3) {$\Kleene{(\Pos\Char{a} \Spc \Char{a} \Union \Pos\Char{b})}\Pos$};
    \draw (u0) edge[->] node[auto]{$\Char{a}$} (u1);
    \draw (u1) edge[->] node[auto]{$\Char{a}$} (u2);
    \draw (u0) edge[->] node[auto]{$\Char{b}$} (u3.west);

    \node[state, initial, accepting, below=3 of u0, label=above left:$\Automaton{\RE{r}}$] (p0) {$\Kleene{(\Pos\Char{a} \Spc \Char{a} \Union \Pos\Char{b})}\Pos$};
    \node[state, right=of p0] (p1) {$\Kleene{(\Char{a} \Pos \Char{a} \Union \Char{b})}$};
    \draw (p0.north east) edge[->, bend left, shorten <>=-2pt+\pgflinewidth] node[auto]{$\Char{a}$} (p1.north west);
    \draw (p1.south west) edge[->, bend left, shorten <>=-2pt+\pgflinewidth] node[auto]{$\Char{a}$} (p0.south east);
    \draw (p0) edge[->, loop below] node[auto]{$\Char{b}$} (p0);
  \end{tikzpicture}
\end{center}

\Next

\subsection{Pozitivno zaprtje}
\Reset

\begin{tcolorbox}[title={Definicija}]
  \begin{equation*}
    \begin{aligned}
      \KleenePlus{\RE{s}} &= \RE{s} \Union \RE{s} \Seq \RE{s} \Union \RE{s} \Seq \RE{s} \Seq \RE{s} \Union \ldots \\
      &= \Rep{\RE{s}}{1} \Union \Rep{\RE{s}}{2} \Union \ldots \\
      &= \Big\vert_{i = 1}^\infty \Rep{\RE{s}}{i}\\
      \Language{\KleenePlus{\RE{s}}} &= \bigcup_{i = 1}^\infty \Language{\RE{s}^i}
    \end{aligned}
  \end{equation*}
\end{tcolorbox}

\begin{tcolorbox}[title={Pravila}]
  \begin{equation*}
    \begin{aligned}
      \Kleene{\RE{s}} &= \Null \Union \KleenePlus{\RE{s}} = \Opt{(\KleenePlus{\RE{s}})} = \KleenePlus{(\Opt{\RE{s}})}\\
      \Language{\Kleene{\RE{r}}} &= \{\Str{}\} \cup \Language{\KleenePlus{\RE{r}}}
    \end{aligned}
  \end{equation*}
\end{tcolorbox}

Ujemanje $s$ 1 ali več krat.
Z drugimi besedami, $s$ je lahko ponovljen $1, 2, \dots, \infty$ krat.

\begin{tcolorbox}[title={Konstrukcija}]
\begin{equation*}
  \begin{aligned}
    \Pos(\KleenePlus{\RE{R}}) &\Move \KleenePlus{(\Pos\RE{R})}\\
    \KleenePlus{(\RE{R}\Pos)} &\Move (\KleenePlus{(\Pos\RE{R})})\Pos
  \end{aligned}
\end{equation*}
\end{tcolorbox}

\Ex
\begin{align*}
  \N{\RE{s}} &= \Char{a}\\
  \N{\RE{r}} &= \KleenePlus{\Char{a}}
\end{align*}

\begin{align*}
  \Language{\N{\RE{s}}} &= \{\Str{a}\}\\
  \Language{\N{\RE{r}}} &= \{\Str{a}, \Str{aa}, \Str{aaa}, \dots\}
\end{align*}

\begin{equation*}
  \Pos(\KleenePlus{\Char{a}}) \Move
  \KleenePlus{(\Pos\Char{a})} \MoveX{\Char{a}}
  \KleenePlus{(\Char{a}\Pos)} \Move
  (\KleenePlus{(\Pos\Char{a})})\Pos \MoveX{\Char{a}}
  \KleenePlus{(\Char{a}\Pos)} \Move
  (\KleenePlus{(\Pos\Char{a})})\Pos \MoveX{\Char{a}} \cdots
\end{equation*}

\begin{center}
  \begin{tikzpicture}
    \tikzset{
      node distance=1cm,
      every state/.style={rectangle, rounded corners, inner sep=0.5em},
      initial text=$ $,
    }
    \node[state, initial, label=above left:$\Automaton{\RE{r}}$] (u0) {$\KleenePlus{(\Pos\Char{a})}$};
    \node[state, accepting, right=of u0, label={above right:=}] (u1) {$\KleenePlus{(\Pos\Char{a})}\Pos$};
    \node[state, accepting, right=of u1, label={above right:=}] (u2) {$\KleenePlus{(\Pos\Char{a})}\Pos$};
    \draw (u0) edge[->] node[auto]{$\Char{a}$} (u1);
    \draw (u1) edge[->] node[auto]{$\Char{a}$} (u2);

    \node[state, initial, below=of u0, label=above left:$\Automaton{\RE{r}}$] (p0) {$\KleenePlus{(\Pos\Char{a})}$};
    \node[state, accepting, right=of p0] (p1) {$\KleenePlus{(\Pos\Char{a})}\Pos$};
    \draw (p0) edge[->] node[auto]{$\Char{a}$} (p1);
    \draw (p1) edge[->, loop right] node[auto]{$\Char{a}$} (p1);
  \end{tikzpicture}
\end{center}

\subsection*{Primeri}
\subsubsection{Števila}
\begin{equation*}
  \N{\RE{r}} = \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}
\end{equation*}
\Next

\subsubsection{Naravna števila}
\begin{equation*}
  \Language{\N{\RE{r}}} = \{\Str{1}, \Str{2}, \dots\}
\end{equation*}
\Next

\subsubsection{Cela števila}
\begin{equation*}
  \N{\RE{r}} = (\Char{+} \Union \Char{-}) \Seq \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}
\end{equation*}
\Next

\subsubsection{Heksadecimalna števila}
\begin{equation*}
  \Language{\N{\RE{r}}} = \{\Str{0x0}, \Str{0x1}, \dots, \Str{0xA}, \dots, \Str{0xFFFF}, \dots\}
\end{equation*}
\Next

\subsubsection{Barve}
\begin{equation*}
  \Language{\N{\RE{r}}} = \{\Str{\#000000}, \dots, \Str{\#FFFFFF}\}
\end{equation*}
\Next

\subsubsection{Števila s plavajočo vejico}
\begin{equation*}
  \N{\RE{r}} = (\Char{+} \Union \Char{-}) \Seq \KleenePlus{\{\Char{0}, \dots, \Char{9}\}} \Spc \Char{.} \Spc \Kleene{\{\Char{0}, \dots, \Char{9}\}}
\end{equation*}
\Next

\subsubsection{Imena spremenljivk}
\begin{equation*}
  \N{\RE{r}} = \KleenePlus{\{\Char{a}, \dots, \Char{z}\}}
\end{equation*}

\subsubsection{Ključne besede in imena spremenljivk}
\begin{align*}
  \N{\RE{r}} &= \KleenePlus{\{\Char{a}, \dots, \Char{z}\}}\\
  \N{\RE{p}} &= \Char{a} \Spc \Char{b}\\
  \N{\RE{q}} &= \Char{a} \Spc \Char{b} \Spc \Char{c}\\
  \N{\RE{t}} &= \Char{a} \Spc \Char{c} \Spc \Char{d}
\end{align*}

\hspace*{-90px}
\begin{tikzpicture}
  \tikzset{
    ->,
    node distance=1cm,
    every state/.style={rectangle, rounded corners, inner sep=0.5em},
    initial text=$ $,
  }

  \clip (-3.45,-5) rectangle (30, 10);

  \node[state, initial, label=above left:$\Automaton{\N{r}}$] (v0) {$\begin{aligned}
    \N{\RE{r}} &= \KleenePlus{\{\Pos\Char{a}, \dots, \Pos\Char{z}\}}\\
    \N{\RE{p}} &= \Pos\Char{a} \Spc \Char{b}\\
    \N{\RE{q}} &= \Pos\Char{a} \Spc \Char{b} \Spc \Char{c}\\
    \N{\RE{t}} &= \Pos\Char{a} \Spc \Char{c} \Spc \Char{d}
  \end{aligned}$};

  \node[state, accepting, right=of v0] (v1) {$\begin{aligned}
    \underline{\N{\RE{r}}} &= \KleenePlus{\{\Pos\Char{a}, \dots, \Pos\Char{z}\}}\Pos\\
    \N{\RE{p}} &= \Char{a} \Pos \Char{b}\\
    \N{\RE{q}} &= \Char{a} \Pos \Char{b} \Spc \Char{c}\\
    \N{\RE{t}} &= \Char{a} \Pos \Char{c} \Spc \Char{d}
  \end{aligned}$};

  \node[state, accepting, right=of v1] (v2) {$\begin{aligned}
    \N{\RE{r}} &= \KleenePlus{\{\Pos\Char{a}, \dots, \Pos\Char{z}\}}\Pos\\
    \underline{\N{\RE{p}}} &= \Char{a} \Spc \Char{b}\Pos\\
    \N{\RE{q}} &= \Char{a} \Spc \Char{b} \Pos \Char{c}\\
    \N{\RE{t}} &= \Char{a} \Spc \Char{c} \Spc \Char{d}
  \end{aligned}$};
  \draw (v0) edge[->] node[auto]{$\Char{a}$} (v1);
  \draw (v1) edge[->] node[auto]{$\Char{b}$} (v2);

  \node[state, accepting, right=of v2] (v3) {$\begin{aligned}
    \N{\RE{r}} &= \KleenePlus{\{\Pos\Char{a}, \dots, \Pos\Char{z}\}}\Pos\\
    \N{\RE{p}} &= \Char{a} \Spc \Char{b}\\
    \underline{\N{\RE{q}}} &= \Char{a} \Spc \Char{b} \Spc \Char{c} \Pos\\
    \N{\RE{t}} &= \Char{a} \Spc \Char{c} \Spc \Char{d}
  \end{aligned}$};
  \draw (v2) edge[->] node[auto]{$\Char{c}$} (v3);

  \node[state, accepting, below right=of v1] (v4) {$\begin{aligned}
    \underline{\N{\RE{r}}} &= \KleenePlus{\{\Pos\Char{a}, \dots, \Pos\Char{z}\}}\Pos\\
    \N{\RE{p}} &= \Char{a} \Spc \Char{b}\\
    \N{\RE{q}} &= \Char{a} \Spc \Char{b} \Spc \Char{c}\\
    \N{\RE{t}} &= \Char{a} \Spc \Char{c} \Pos \Char{d}
  \end{aligned}$};

  \node[state, accepting, right=of v4] (v5) {$\begin{aligned}
    \N{\RE{r}} &= \KleenePlus{\{\Pos\Char{a}, \dots, \Pos\Char{z}\}}\Pos\\
    \N{\RE{p}} &= \Char{a} \Spc \Char{b}\\
    \N{\RE{q}} &= \Char{a} \Spc \Char{b} \Spc \Char{c}\\
    \underline{\N{\RE{t}}} &= \Char{a} \Spc \Char{c} \Spc \Char{d} \Pos
  \end{aligned}$};

  \draw (v1) edge[->] node[auto]{$\Char{c}$} (v4);
  \draw (v4) edge[->] node[auto]{$\Char{d}$} (v5);

  \node[state, accepting, above=2cm of v1] (s) {$\begin{aligned}
    \underline{\N{\RE{r}}} &= \KleenePlus{\{\Pos\Char{a}, \dots, \Pos\Char{z}\}}\Pos\\
    \N{\RE{p}} &= \Char{a} \Spc \Char{b}\\
    \N{\RE{q}} &= \Char{a} \Spc \Char{b} \Spc \Char{c}\\
    \N{\RE{t}} &= \Char{a} \Spc \Char{c} \Spc \Char{d}
  \end{aligned}$};

  \draw (v0) edge[->, bend left] node[auto]{$A - \{\Char{a}\}$} (s);
  \draw (v1) edge[->, bend right] node[auto]{$A - \{\Char{b}, \Char{c}\}$} (s);
  \draw (v2) edge[->, bend right] node[right]{$A - \{\Char{c}\}$} (s);
  \draw (v3) edge[->, bend right=50] node[above right]{$A$} (s);
  \draw (v4) edge[->, out=-150, in=170, looseness=2.5] node[left ]{$A - \{\Char{d}\}$} (s);
  \draw (v5) edge[->, out=25, in=45, looseness=1.2] node[right]{$A$} (s);
  \draw (s) edge[->, loop] node[above]{$A$} (s);
\end{tikzpicture}

\chapter{Gramatike}

Gramatika je tuple $G = (\NonTerminals, \Terminals, \Productions, \NT{S})$, kjer je $\NonTerminals$ končna množica neterminalnih simbolov, $\Terminals$ končna množica terminalnih simbolov, $\Productions$ je končna relacija produkcij $\NonTerminals \times \Kleene{(\NonTerminals \cup \Terminals)}$ in $\NT{S} \in \NonTerminals$ je začetni simbol.

\begin{equation*}
  \Language{\NT{A}} = \{w \mid \NT{A} \DeriveStar w\}
\end{equation*}

\begin{equation*}
  \Language{G} = \Language{\NT{S}}
\end{equation*}

\section{Osnovne gramatike}
Gramatike so v veliki meri sestavljene iz naslednjih osnovnih vzorcev.

\subsubsection{Seznam}
\begin{equation*}
  \begin{aligned}[t]
    \NT{L} &\Arrow \T{i} \Spc \NT{L} \Union \Null\\[1em]
    \NT{Numbers} &\Arrow \T{num} \Spc \NT{Numbers} \Union \Null\\[1em]
    \T{num} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}
  \end{aligned}
\end{equation*}
\begin{lstlisting}
$\Null$
1
1 2
1 2 3
\end{lstlisting}

\subsubsection{Seznam z ločilom}
\begin{equation*}
  \begin{aligned}[t]
    \NT{L} &\Arrow \T{i} \Spc \T{s} \Spc \NT{L} \Union \Null\\[1em]
    \NT{Numbers} &\Arrow \T{num} \Spc \T{sep} \Spc \NT{Numbers} \Union \Null\\[1em]
    \T{num} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}\\
    \T{sep} &= \Char{;}
  \end{aligned}
\end{equation*}
\begin{lstlisting}
$\Null$
1;
1; 2;
1; 2; 3;
\end{lstlisting}
Ločilo je tudi na koncu.

\subsubsection{Neprazen seznam}
Da lahko neprazen seznam razpoznamo z LL(1) razpoznavalnikom moramo gramatiko preoblikovati.
\begin{equation*}
  \begin{aligned}[t]
    \NT{L} &\Arrow \T{i} \Spc \NT{L} \Union \T{i}\\[1em]
    \NT{L} &\Arrow \T{i} \Seq (\NT{L} \Union \Null)\text{\quad izpostavimo $\T{i}$}\\[1em]
    \NT{L} &\Arrow \T{i} \Spc \NT{L'}\\
    \NT{L'} &\Arrow \NT{L} \Union \Null \text{\quad oklepaje spremenimo v novo produkcijo}\\[1em]
    \NT{L} &\Arrow \T{i} \Spc \NT{L'}\\
    \NT{L'} &\Arrow \T{i} \Spc \NT{L'} \Union \Null \text{\quad zamenjamo $\NT{L}$ z desno stranjo}\\[1em]
    \NT{L} &\Arrow \T{i} \Seq \Kleene{\T{i}}\\[1em]
    \NT{Numbers} &\Arrow \T{num} \Spc \NT{Numbers} \Union \T{num}\\[1em]
    \NT{Numbers} &\Arrow \T{num} \Spc \NT{Numbers'}\\
    \NT{Numbers'} &\Arrow \T{num} \Spc \NT{Numbers'} \Union \Null\\[1em]
    \NT{Numbers} &\Arrow \T{num} \Spc \Kleene{\T{num}}\\[1em]
    \T{num} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}
  \end{aligned}
\end{equation*}
\begin{lstlisting}
1
1 2
1 2 3
\end{lstlisting}

\subsubsection{Neprazen seznam z ločilom}
\begin{equation*}
  \begin{aligned}[t]
    \NT{L} &\Arrow \T{i} \Spc \T{s} \Spc \NT{L} \Union \T{i}\\[1em]
    \NT{L} &\Arrow \T{i} \Seq (\T{s} \Spc \NT{L} \Union \Null)\text{\quad izpostavimo $\T{i}$}\\[1em]
    \NT{L} &\Arrow \T{i} \Spc \NT{L'}\\
    \NT{L'} &\Arrow \T{s} \Spc \NT{L} \Union \Null \text{\quad oklepaje spremenimo v novo produkcijo}\\[1em]
    \NT{L} &\Arrow \T{i} \Spc \NT{L'}\\
    \NT{L'} &\Arrow \T{s} \Spc \T{i} \Spc \NT{L'} \Union \Null \text{\quad zamenjamo $\NT{L}$ z desno stranjo}\\[1em]
    \NT{L} &\Arrow \T{i} \Seq \Kleene{(\T{s} \Spc \T{i})}\\[1em]
    \NT{Numbers} &\Arrow \T{num} \Spc \T{sep} \Spc \NT{Numbers} \Union \T{num}\\[1em]
    \NT{Numbers} &\Arrow \T{num} \Spc \NT{Numbers'}\\
    \NT{Numbers'} &\Arrow \T{sep} \Spc \T{num} \Spc \NT{Numbers'} \Union \Null\\[1em]
    \NT{Numbers} &\Arrow \T{num} \Spc \Kleene{(\T{sep} \Spc \T{num})}\\[1em]
    \T{num} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}\\
    \T{sep} &= \Char{+}
  \end{aligned}
\end{equation*}
\begin{lstlisting}
1
1 + 2
1 + 2 + 3
\end{lstlisting}
Ločila ni na koncu.

\subsubsection{Opcijsko}
\begin{equation*}
  \begin{aligned}[t]
    \NT{B} &\Arrow \NT{C} \Spc \T{i}\\
    \NT{C} &\Arrow \T{i} \Union \Null \\[1em]
    \NT{Val} &\Arrow \NT{Sign} \Spc \T{num}\\
    \NT{Sign} &\Arrow \T{plus} \Union \T{minus} \Union \Null\\[1em]
    \T{num} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}\\
    \T{plus} &= \Char{+}\\
    \T{minus} &= \Char{-}
  \end{aligned}
\end{equation*}
\begin{lstlisting}
1
+1
-1
\end{lstlisting}

\subsubsection{Vsebovanje}
Nekaj znotraj nečesa.
\begin{equation*}
  \begin{aligned}[t]
    \NT{B} &\Arrow \T{l} \Spc \T{C} \Spc \T{r}\\
    \NT{C} &\Arrow \T{i}\\[1em]
    \NT{Box} &\Arrow \T{lbrak} \Spc \NT{Val} \Spc \T{rbrak}\\
    \NT{Val} &\Arrow \T{num} \Union \T{star}\\[1em]
    \T{num} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}\\
    \T{lbrak} &= \Char{[}\\
    \T{rbrak} &= \Char{]}\\
    \T{star} &= \Char{*}
  \end{aligned}
\end{equation*}
\begin{lstlisting}
[*]
[1]
\end{lstlisting}

\begin{equation*}
  \begin{aligned}[t]
    \NT{B} &\Arrow \T{l} \Spc \T{L} \Spc \T{r}\\
    \NT{L} &\Arrow \T{i} \Spc \NT{L'}\\
    \NT{L'} &\Arrow \T{s} \Spc \T{i} \Spc \NT{L'} \Union \Null\\[1em]
    \NT{Box} &\Arrow \T{lbrak} \Spc \NT{Numbers} \Spc \T{rbrak}\\
    \NT{Numbers} &\Arrow \T{num} \Spc \NT{Numbers'}\\
    \NT{Numbers'} &\Arrow \T{sep} \Spc \T{num} \Spc \NT{Numbers'} \Union \Null\\[1em]
    \T{num} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}\\
    \T{lbrak} &= \Char{[}\\
    \T{rbrak} &= \Char{]}\\
    \T{sep} &= \Char{+}
  \end{aligned}
\end{equation*}
\begin{lstlisting}
[1]
[1 + 2]
[1 + 2 + 3]
\end{lstlisting}

\subsubsection{Gnezdenje}

\begin{equation*}
  \begin{aligned}[t]
    \NT{B} &\Arrow \T{l} \Spc \NT{B} \Spc \T{r} \Union \NT{C}\\
    \NT{C} &\Arrow \T{i}\\[1em]
    \NT{Box} &\Arrow \T{lbrak} \Spc \NT{Box} \Spc \T{rbrak} \Union \NT{Val}\\
    \NT{Val} &\Arrow \T{num} \Union \T{star}\\[1em]
    \T{num} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}\\
    \T{lbrak} &= \Char{[}\\
    \T{rbrak} &= \Char{]}\\
    \T{star} &= \Char{*}
  \end{aligned}
\end{equation*}
\begin{lstlisting}
[*]
[[[1]]]
[[[[[[[1]]]]]]]
\end{lstlisting}

\begin{equation*}
  \begin{aligned}[t]
    \NT{L} &\Arrow \NT{C} \Spc \NT{L'}\\
    \NT{L'} &\Arrow \T{s} \Spc \NT{C} \Spc \NT{L'} \Union \Null\\
    \NT{C} &\Arrow \T{i} \Union \NT{L}\\[1em]
    \NT{Numbers} &\Arrow \T{Val} \Spc \NT{Numbers'}\\
    \NT{Numbers'} &\Arrow \T{sep} \Spc \T{Val} \Spc \NT{Numbers'} \Union \Null\\
    \NT{Val} &\Arrow \T{num} \Union \T{lbrak} \Spc \NT{Numbers} \Spc \T{rbrak}\\[1em]
    \T{num} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}\\
    \T{lbrak} &= \Char{[}\\
    \T{rbrak} &= \Char{]}\\
    \T{sep} &= \Char{+}
  \end{aligned}
\end{equation*}
\begin{lstlisting}
[1]
[[[1] + [2] + [3]]]
[[1 + [2] + [1 + 2 + 3]]]
\end{lstlisting}

\subsection*{Izrazi}

Abstraktna sintaksa za izraze.
\begin{align*}
  \NT{Start} &\Arrow \NT{Expr}\\
  \NT{Expr} &\Arrow \NT{Expr} \Spc \T{plus} \Spc \NT{Expr}\\
  &\Union \NT{Expr} \Spc \T{minus} \Spc \NT{Expr}\\
  &\Union \NT{Expr} \Spc \T{times} \Spc \NT{Expr}\\
  &\Union \NT{Expr} \Spc \T{divide} \Spc \NT{Expr}\\
  &\Union \T{plus} \Spc \NT{Expr} \Union \T{minus} \Spc \NT{Expr}\\
  &\Union \T{int} \Union \T{variable}
\end{align*}
Ta gramatika je dvoumna.

Določimo prioriteto.
\begin{align*}
  \NT{Start} &\Arrow \NT{Additive}\\
  \NT{Additive} &\Arrow \NT{Additive} \Spc \T{plus} \Spc \NT{Additive} \Union \NT{Additive} \Spc \T{minus} \Spc \NT{Additive} \Union \NT{Multiplicative}\\
  \NT{Multiplicative} &\Arrow \NT{Multiplicative} \Spc \T{times} \Spc \NT{Multiplicative} \Union \NT{Multiplicative} \Spc \T{divide} \Spc \NT{Multiplicative} \Union \NT{Unary}\\
  \NT{Unary} &\Arrow \T{plus} \Spc \NT{Primary} \Union \T{minus} \Spc \NT{Primary} \Union \NT{Primary}\\ 
  \NT{Primary} &\Arrow \T{int} \Union \T{variable} \Union \T{lparen} \Spc \NT{Additive} \Spc \T{rparen}
\end{align*}

Določimo asociativnost.
\begin{align*}
  \NT{Start} &\Arrow \NT{Additive}\\
  \NT{Additive} &\Arrow \NT{Additive} \Spc \T{plus} \Spc \NT{Multiplicative} \Union \NT{Additive} \Spc \T{minus} \Spc \NT{Multiplicative} \Union \NT{Multiplicative}\\
  \NT{Multiplicative} &\Arrow \NT{Multiplicative} \Spc \T{times} \Spc \NT{Unary} \Union \NT{Multiplicative} \Spc \T{divide} \Spc \NT{Unary} \Union \NT{Unary}\\
  \NT{Unary} &\Arrow \T{plus} \Spc \NT{Primary} \Union \T{minus} \Spc \NT{Primary} \Union \NT{Primary}\\ 
  \NT{Primary} &\Arrow \T{int} \Union \T{variable} \Union \T{lparen} \Spc \NT{Additive} \Spc \T{rparen}
\end{align*}
Ta gramatika je enoumna, vendar ni LL(1), saj imamo levo rekurzijo.

Obrnemo asociativnost (to bomo morali kasneje popraviti).
\begin{align*}
  \NT{Start} &\Arrow \NT{Additive}\\
  \NT{Additive} &\Arrow \NT{Multiplicative} \Spc \T{plus} \Spc \NT{Additive} \Union \NT{Multiplicative} \Spc \T{minus} \Spc \NT{Additive} \Union \NT{Multiplicative}\\
  \NT{Multiplicative} &\Arrow \NT{Unary} \Spc \T{times} \Spc \NT{Multiplicative} \Union \NT{Unary} \Spc \T{divide} \Spc \NT{Multiplicative} \Union \NT{Unary}\\
  \NT{Unary} &\Arrow \T{plus} \Spc \NT{Primary} \Union \T{minus} \Spc \NT{Primary} \Union \NT{Primary}\\ 
  \NT{Primary} &\Arrow \T{int} \Union \T{variable} \Union \T{lparen} \Spc \NT{Additive} \Spc \T{rparen}
\end{align*}

Izpostavimo.
\begin{align*}
  \NT{Start} &\Arrow \NT{Additive}\\
  \NT{Additive} &\Arrow \NT{Multiplicative} \Seq (\T{plus} \Spc \NT{Additive} \Union \T{minus} \Spc \NT{Additive} \Union \Null)\\
  \NT{Multiplicative} &\Arrow \NT{Unary} \Seq (\T{times} \Spc \NT{Multiplicative} \Union \T{divide} \Spc \NT{Multiplicative} \Union \Null)\\
  \NT{Unary} &\Arrow \T{plus} \Spc \NT{Primary} \Union \T{minus} \Spc \NT{Primary} \Union \NT{Primary}\\ 
  \NT{Primary} &\Arrow \T{int} \Union \T{variable} \Union \T{lparen} \Spc \NT{Additive} \Spc \T{rparen}
\end{align*}

Oklepaje spremenimo v novo produkcijo.
\begin{align*}
  \NT{Start} &\Arrow \NT{Additive}\\
  \NT{Additive} &\Arrow \NT{Multiplicative} \Spc \NT{Additive'}\\
  \NT{Additive'} &\Arrow \T{plus} \Spc \NT{Additive} \Union \T{minus} \Spc \NT{Additive} \Union \Null\\
  \NT{Multiplicative} &\Arrow \NT{Unary} \Spc \NT{Multiplicative'}\\
  \NT{Multiplicative'} &\Arrow \T{times} \Spc \NT{Multiplicative} \Union \T{divide} \Spc \NT{Multiplicative} \Union \Null\\
  \NT{Unary} &\Arrow \T{plus} \Spc \NT{Primary} \Union \T{minus} \Spc \NT{Primary} \Union \NT{Primary}\\ 
  \NT{Primary} &\Arrow \T{int} \Union \T{variable} \Union \T{lparen} \Spc \NT{Additive} \Spc \T{rparen}
\end{align*}

Odpravimo \emph{mutual} rekurzijo (vstavimo).
\begin{align*}
  \NT{Start} &\Arrow \NT{Additive}\\[1em]
  \NT{Additive} &\Arrow \NT{Multiplicative} \Spc \NT{Additive'}\\
  \NT{Additive'} &\Arrow \T{plus} \Spc \NT{Multiplicative} \Spc \NT{Additive'} \Union \T{minus} \Spc \NT{Multiplicative} \Spc \NT{Additive'} \Union \Null\\[1em]
  \NT{Multiplicative} &\Arrow \NT{Unary} \Spc \NT{Multiplicative'}\\
  \NT{Multiplicative'} &\Arrow \T{times} \Spc \NT{Unary} \Spc \NT{Multiplicative'} \Union \T{divide} \Spc \NT{Unary} \Spc \NT{Multiplicative'} \Union \Null\\[1em]
  \NT{Unary} &\Arrow \T{plus} \Spc \NT{Primary} \Union \T{minus} \Spc \NT{Primary} \Union \NT{Primary}\\[1em]
  \NT{Primary} &\Arrow \T{int} \Union \T{variable} \Union \T{lparen} \Spc \NT{Additive} \Spc \T{rparen}
\end{align*}
Ta gramatika je LL(1).

\Ex
\begin{lstlisting}
1 * 2 + 3
\end{lstlisting}
\begin{equation*}
  \begin{aligned}
    \NT{Start} &\Derive \NT{Additive}\\
    &\Derive \NT{Multiplicative} \Spc \NT{Additive'}\\
    &\Derive \NT{Unary} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \NT{Primary} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \NT{Unary} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \NT{Primary} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{int} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{int} \Spc \Null \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{int} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{int} \Spc \T{plus} \Spc \NT{Multiplicative} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{int} \Spc \T{plus} \Spc \NT{Unary} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{int} \Spc \T{plus} \Spc \NT{Primary} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{int} \Spc \T{plus} \Spc \T{int} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{int} \Spc \T{plus} \Spc \T{int} \Spc \Null \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{int} \Spc \T{plus} \Spc \T{int} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{int} \Spc \T{plus} \Spc \T{int} \Spc \Null\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{int} \Spc \T{plus} \Spc \T{int}
  \end{aligned}
\end{equation*}
Na vrhu je $\NT{Additive}$.

\newpage
\Ex
\begin{lstlisting}
1 * (2 + 3)
\end{lstlisting}
\begin{equation*}
  \begin{aligned}
    \NT{Start} &\Derive \NT{Additive}\\
    &\Derive \NT{Multiplicative} \Spc \NT{Additive'}\\
    &\Derive \NT{Unary} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \NT{Primary} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \NT{Unary} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \NT{Primary} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{lparen} \Spc \NT{Additive} \Spc \T{rparen} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{lparen} \Spc \NT{Multiplicative} \Spc \NT{Additive'} \Spc \T{rparen} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{lparen} \Spc \NT{Unary} \Spc \NT{Additive'} \Spc \T{rparen} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{lparen} \Spc \NT{Primary} \Spc \NT{Additive'} \Spc \T{rparen} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{lparen} \Spc \T{int} \Spc \NT{Additive'} \Spc \T{rparen} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{lparen} \Spc \T{int} \Spc \T{plus} \Spc \NT{Multiplicative} \Spc \NT{Additive'} \Spc \T{rparen} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{lparen} \Spc \T{int} \Spc \T{plus} \Spc \NT{Unary} \Spc \NT{Additive'} \Spc \T{rparen} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{lparen} \Spc \T{int} \Spc \T{plus} \Spc \NT{Primary} \Spc \NT{Additive'} \Spc \T{rparen} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{lparen} \Spc \T{int} \Spc \T{plus} \Spc \T{int} \Spc \NT{Additive'} \Spc \T{rparen} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{lparen} \Spc \T{int} \Spc \T{plus} \Spc \T{int} \Spc \Null \Spc \T{rparen} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{lparen} \Spc \T{int} \Spc \T{plus} \Spc \T{int} \Spc \T{rparen} \Spc \NT{Multiplicative'} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{lparen} \Spc \T{int} \Spc \T{plus} \Spc \T{int} \Spc \T{rparen} \Spc \Null \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{lparen} \Spc \T{int} \Spc \T{plus} \Spc \T{int} \Spc \T{rparen} \Spc \NT{Additive'}\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{lparen} \Spc \T{int} \Spc \T{plus} \Spc \T{int} \Spc \T{rparen} \Spc \Null\\
    &\Derive \T{int} \Spc \T{times} \Spc \T{lparen} \Spc \T{int} \Spc \T{plus} \Spc \T{int} \Spc \T{rparen}
  \end{aligned}
\end{equation*}
Na vrhu je $\NT{Multiplicative}$, do $\NT{Additive}$ pridemo skozi oklepaje.

Gramatiko lahko bolj kompaktno predstavimo z uporabo EBNF, kjer imajo produkcije regularne izraze na desni strani.
\begin{align*}
  \NT{Start} &\Arrow \NT{Additive}\\
  \NT{Additive} &\Arrow \NT{Multiplicative} \Spc \Kleene{(\T{plus} \Spc \NT{Multiplicative} \Union \T{minus} \Spc \NT{Multiplicative})}\\
  \NT{Multiplicative} &\Arrow \NT{Unary} \Spc \Kleene{(\T{times} \Spc \NT{Unary} \Spc \Union \T{divide} \Spc \NT{Unary})}\\
  \NT{Unary} &\Arrow \T{plus} \Spc \NT{Primary} \Union \T{minus} \Spc \NT{Primary} \Union \NT{Primary}\\
  \NT{Primary} &\Arrow \T{int} \Union \T{variable} \Union \T{lparen} \Spc \NT{Additive} \Spc \T{rparen}
\end{align*}

Še bolj kompaktna oblika.
\begin{align*}
  \NT{Start} &\Arrow \NT{Additive}\\
  \NT{Additive} &\Arrow \NT{Multiplicative} \Spc \Kleene{((\T{plus} \Union \T{minus}) \Spc \NT{Multiplicative})}\\
  \NT{Multiplicative} &\Arrow \NT{Unary} \Spc \Kleene{((\T{times} \Union \T{divide}) \Spc \NT{Unary})}\\
  \NT{Unary} &\Arrow \Opt{(\T{plus} \Union \T{minus})} \Spc \NT{Primary}\\
  \NT{Primary} &\Arrow \T{int} \Union \T{variable} \Union \T{lparen} \Spc \NT{Additive} \Spc \T{rparen}
\end{align*}

\section{FIRST}
\begin{tcolorbox}[title={Definicija}]
  \begin{equation*}
    \begin{aligned}
      \FIRST(L) &= \{ \T{a} \mid \T{a} \Spc \beta \in L \}\\[1em]
      \FIRST(\alpha) &= \{\T{a} \mid \alpha \DeriveStar \T{a} \Spc \beta \land \T{a} \in \Terminals\}\\[1em]
      \FIRST(r \Seq s) &= \FIRST(\FIRST(r) \Seq \FIRST(s))\\
      \FIRST(r \Union s) &= \FIRST(r) \cup \FIRST(s)\\
      \FIRST(\NT{A}) &= \FIRST(r)\text{, kjer } \T{A} \in \NonTerminals \land \NT{A} \Arrow r \in \Productions\\
      \FIRST(\T{a}) &= \FIRST(\T{a})\text{, kjer } \T{a} \in \Terminals\\
      \FIRST(\Null) &= \{\Null\}\\
      \FIRST(\Empty) &= \Empty
    \end{aligned}
  \end{equation*}
\end{tcolorbox}

Po \cite{dragonbook} za izračun $\FIRST(\Sym{X})$ za vse simbole $\Sym{X}$ uporabimo naslednja pravila, dokler novih terminalov ali $\Null$ več ni mogoče dodati kateri koli $\FIRST$ množici.

\begin{enumerate}
  \item Če je $\Sym{X}$ terminal potem $\FIRST(\Sym{X}) = \{\Sym{X}\}$.
  \item Če je $\Sym{X}$ neterminal in obstaja produkcija $\Sym{X} \Arrow \Sym{Y}_1 \Spc \Sym{Y}_2 \Spc \dots \Spc \Sym{Y}_k$ za nek $k \geq 1$, potem dodamo $\T{a}$ v $\FIRST(\Sym{X})$, če je za nek $i$, $\T{a}$ v $\FIRST(\Sym{Y}_i)$, in vsi $\FIRST(\Sym{Y}_1), \dots, \FIRST(\Sym{Y}_{i - 1})$ vsebujejo $\Null$; torej $\Sym{Y}_1 \dots \Sym{Y}_{i - 1} \DeriveStar \Null$.
    Če je $\Null$ v vseh $\FIRST(\Sym{Y}_j)$ za vse $j = 1, 2, \dots, k$, potem dodamo $\Null$ v $\FIRST(\Sym{X})$.
  \item Če obstaja produkcija $\Sym{X} \Arrow \Null$ potem dodamo $\Null$ v $\FIRST(\Sym{X})$.
\end{enumerate}

Za izračun $\FIRST$ niza $\Sym{X}_1 \Spc \Sym{X}_2 \Spc \dots \Spc \Sym{X}_n$ dodamo v $\FIRST(\Sym{X}_1 \Spc \Sym{X}_2 \Spc \dots \Spc \Sym{X}_n)$ vse simbole iz $\FIRST(\Sym{X}_1)$ razen $\Null$. Nato dodamo vse simbole iz $\FIRST(\Sym{X}_2)$, če je $\Null$ v $\FIRST(\Sym{X}_1)$; vse simbole iz $\FIRST(\Sym{X}_3)$, če je $\Null$ v $\FIRST(\Sym{X}_1)$ in $\FIRST(\Sym{X}_2)$; in tako dalje.
Na koncu dodamo $\Null$ v $\FIRST(\Sym{X}_1 \Spc \Sym{X}_2 \Spc \dots \Spc \Sym{X}_n)$, če je, za vse $i$, $\Null$ v $\FIRST(\Sym{X}_i)$.

\section{FOLLOW}
\begin{tcolorbox}[title={Definicija}]
  \begin{equation*}
    \begin{aligned}
      \FOLLOW(\NT{B}) &= \{ \FIRST(\eta \Seq \EOF) \mid \NT{S} \Seq \EOF \DeriveStar \gamma \Spc \NT{B} \Spc \eta \Seq \EOF \}\\[1em]
      \FOLLOW(\NT{S}) &= \{\EOF\}\\
      \FOLLOW(\NT{B}) &= \FIRST(\FIRST(\beta) \Seq \FOLLOW(\NT{A}))\text{, kjer } \NT{A} \Arrow \alpha \Spc \NT{B} \Spc \beta \in \Productions
    \end{aligned}
  \end{equation*}
\end{tcolorbox}

Po \cite{dragonbook} za izračun $\FOLLOW$ za vse neterminale $\NT{A}$ uporabimo naslednja pravila, dokler več v $\FOLLOW$ ni mogoče dodati nobenega simbola.
\begin{enumerate}
  \item Dodamo $\EOF$ v $\FOLLOW(\NT{S})$, kjer je $\NT{S}$ začetni simbol.
  \item Če obstaja produkcija $\NT{A} \Arrow \alpha \Spc \NT{B} \Spc \beta$, potem je vse iz $\FIRST(\beta)$ razen $\Null$ v $\FOLLOW(\NT{B})$.
  \item Če obstaja produkcija $\NT{A} \Arrow \alpha \Spc \NT{B}$ ali produkcija $\NT{A} \Arrow \alpha \Spc \NT{B} \Spc \beta$, kjer $\FIRST(\beta)$ vsebuje $\Null$, potem je vse iz $\FOLLOW(\NT{A})$ v $\FOLLOW(\NT{B})$.
\end{enumerate}

\section{Implementacija}
Za vsako produkcijo $\NT{A} \Arrow \gamma \Union \dots \Union \eta \in \Productions$ izračunamo:
\begin{gather*}
  \FIRST(\FIRST(\gamma) \Seq \FOLLOW(\NT{A}))\\
  \dots\\
  \FIRST(\FIRST(\eta) \Seq \FOLLOW(\NT{A}))
\end{gather*}

Pripravimo funkcijo, kjer $\gamma = \Sym{X}_1 \Seq \Sym{X}_2 \Seq \dots \Seq \Sym{X}_n$ in $\eta = \Sym{Y}_1 \Seq \Sym{Y}_2 \Seq \dots \Seq \Sym{Y}_m$:

\begin{algorithm}
  function recognizeA()
    return when lookahead
      $\FIRST(\FIRST(\gamma) \Seq \FOLLOW(\NT{A}))$ $\rightarrow$ recognizeX$_1$() $\&\&$ recognizeX$_2$() $\&\&\ \dots\ \&\&$ recognizeX$_n$()
      $\dots$
      $\FIRST(\FIRST(\eta) \Seq \FOLLOW(\NT{A}))$ $\rightarrow$ recognizeY$_1$() $\&\&$ recognizeY$_2$() $\&\&\ \dots\ \&\&$ recognizeY$_m$()
      else $\rightarrow$ false
\end{algorithm}

Za vsako produkcijo $\NT{A} \Arrow \sigma \in \Productions$ ni potrebno izračunati ničesar, ker imamo na voljo samo eno desno stran in zato ni potrebno izbirati.

Pripravimo funkcijo, kjer $\sigma = \NT{Z}_1 \Seq \NT{Z}_2 \Seq \dots \Seq \NT{Z}_p$:

\begin{algorithm}
  function recognizeA()
    return recognizeZ$_1$() $\&\&$ recognizeZ$_2$() $\&\&\ \dots\ \&\&$ recognizeZ$_p$()
\end{algorithm}

Za vse terminale lahko pripravimo eno samo funkcijo, ki prejme terminal, ki ga želimo razpoznati:
\begin{algorithm}
  function recognizeTerminal($a$)
    $\dots$
\end{algorithm}

Za produkcijo $\NT{S} \Arrow \NT{A}$, kjer je $\NT{S}$ začetni simbol, pripravimo funkcijo:
\begin{algorithm}
  function recognizeStart()
    result = recognizeA()
    return when lookahead
      $\EOF$ $\rightarrow$ result
      else $\rightarrow$ false
\end{algorithm}
Preveriti moramo, ali smo prišli do konca vhoda.

\Ex
\begin{lstlisting}
2 - 1 to b;
print b;
4 to a;
print a;
return a - b
\end{lstlisting}

\subsubsection*{Regularni izrazi}
\begin{equation*}
  \begin{aligned}
    \T{num} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}\\
    \T{var} &= \KleenePlus{\{\Char{a}, \dots, \Char{z}\}}\\
    \T{minus} &= \Char{-}\\
    \T{seq} &= \Char{;}\\
    \T{to} &= \Char{to}\\
    \T{print} &= \Char{print}\\
    \T{return} &= \Char{return}
  \end{aligned}
\end{equation*}

\subsubsection*{Gramatika}
\begin{equation*}
  \begin{aligned}
    \NT{Start} &\Arrow \NT{Stmts}\\
    \NT{Stmts} &\Arrow \NT{Stmt} \Spc \NT{Stmts'}\\
    \NT{Stmts'} &\Arrow \T{seq} \Spc \NT{Stmt} \Spc \NT{Stmts'} \Union \Null\\
    \NT{Stmt} &\Arrow \NT{Expr} \Spc \T{to} \Spc \T{var} \Union \T{print} \Spc \NT{Expr} \Union \NT{return} \Spc \NT{Expr}\\
    \NT{Expr} &\Arrow \NT{Sub}\\
    \NT{Sub} &\Arrow \NT{Primary} \Spc \NT{Sub'}\\
    \NT{Sub'} &\Arrow \T{minus} \Spc \NT{Primary} \Spc \NT{Sub'} \Union \Null\\
    \NT{Primary} &\Arrow \T{num} \Union \T{var}
  \end{aligned}
\end{equation*}

\subsubsection*{{\FIRST}}
\begin{equation*}
  \begin{aligned}
    \FIRST(\T{num}) &= \{\T{num}\}\\
    \FIRST(\T{var}) &= \{\T{var}\}\\
    \FIRST(\T{minus}) &= \{\T{minus}\}\\
    \FIRST(\T{to}) &= \{\T{to}\}\\
    \FIRST(\T{print}) &= \{\T{print}\}\\
    \FIRST(\T{return}) &= \{\T{return}\}\\
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FIRST(\NT{Primary}) &= \FIRST(\T{num} \Union \T{var})\\
    &= \FIRST(\T{num}) \cup \FIRST(\T{var})\\
    &= \{\T{num}\} \cup \{\T{var}\}\\
    &= \{\T{num}, \T{var}\}
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FIRST(\NT{Sub'}) &= \FIRST(\T{minus} \Spc \NT{Primary} \Spc \NT{Sub'} \Union \Null)\\
    &= \FIRST(\T{minus} \Spc \NT{Primary} \Spc \NT{Sub'}) \cup \FIRST(\Null)\\
    &= \{\T{minus}\} \cup \{\Null\}\\
    &= \{\T{minus}, \Null\}\\
    \FIRST(\T{minus} \Spc \NT{Primary} \Spc \NT{Sub'}) 
    &= \FIRST(\FIRST(\T{minus}) \Seq \FIRST(\NT{Primary}) \Seq \FIRST(\NT{Sub'}))\\
    &= \FIRST(\{\T{minus}\} \Seq \{\T{num}, \T{var}\} \Seq (\Empty \cup \FIRST(\Null))))\\
    &= \FIRST(\{\T{minus} \Seq \T{num}, \T{minus} \Seq \T{var} \} \Seq \{\Null\}))\\
    &= \{\T{minus}\}
  \end{aligned}
\end{equation*}
Rekurzija nam ne doda nič novega, torej:
\begin{equation*}
  \begin{aligned}
    \FIRST(A) &= \dots \Spc \FIRST(A) \Spc \dots\\
    \FIRST(A) &= \dots \Spc \Empty \Spc \dots
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FIRST(\NT{Sub}) &= \FIRST(\T{Primary} \Spc \NT{Sub'})\\
    &= \FIRST(\FIRST(\T{Primary}) \Seq \FIRST(\NT{Sub'}))\\
    &= \FIRST(\{\T{num}, \T{var}\} \Seq \{\T{minus}, \Null\})\\
    &= \FIRST(\{\T{num} \Seq \T{minus}, \T{num}, \T{var} \Seq \T{minus}, \T{var}\})\\
    &= \{\T{num}, \T{var}\}
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FIRST(\NT{Expr}) &= \FIRST(\T{Sub})\\
    \FIRST(\NT{Expr}) &= \{\T{num}, \T{var}\}
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FIRST(\NT{Stmt}) &= \FIRST(\NT{Expr} \Spc \T{to} \Spc \T{var} \Union \T{print} \Spc \NT{Expr} \Union \NT{return} \Spc \NT{Expr})\\
    \FIRST(\NT{Expr}) &= \FIRST(\NT{Expr} \Spc \T{to} \Spc \T{var}) \cup \FIRST(\T{print} \Spc \NT{Expr}) \cup \FIRST(\NT{return} \Spc \NT{Expr})\\
    &= \{\T{num}, \T{var}\} \cup \{\T{print}\} \cup \{\T{return}\}\\
    &= \{\T{num}, \T{var}, \T{print}, \T{return}\}\\
    \FIRST(\NT{Expr} \Spc \T{to} \Spc \T{var}) &= \FIRST(\FIRST(\NT{Expr}) \Seq \FIRST(\T{to}) \Seq \FIRST(\T{var}))\\
    &= \FIRST(\{\T{num}, \T{var}\} \Seq \{\T{to}\} \Seq \{\T{var}\})\\
    &= \FIRST(\{\T{num} \Seq \T{to} \Seq \T{var}, \T{var} \Seq \T{to} \Seq \T{var}\})\\
    &= \{\T{num}, \T{var}\}\\
    \FIRST(\T{print} \Spc \NT{Expr}) &= \FIRST(\FIRST(\T{print}) \Seq \FIRST(\NT{Expr}))\\
    &= \FIRST(\{\T{print}\} \Seq \{\T{num}, \T{var}\})\\
    &= \FIRST(\{\T{print}\Seq\T{num}, \T{print} \Seq \T{var}\})\\
    &= \{\T{print}\}\\
    \FIRST(\T{return} \Spc \NT{Expr}) &= \FIRST(\FIRST(\T{return}) \Seq \FIRST(\NT{Expr}))\\
    &= \FIRST(\{\T{return}\} \Seq \{\T{num}, \T{var}\})\\
    &= \FIRST(\{\T{return}\Seq\T{num}, \T{return} \Seq \T{var}\})\\
    &= \{\T{return}\}
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FIRST(\NT{Stmts'}) &= \FIRST(\T{seq} \Spc \NT{Stmt} \Spc \NT{Stmts'} \Union \Null)\\
    & = \{\T{seq}, \Null\}\\
    \FIRST(\T{seq} \Spc \NT{Stmt} \Spc \NT{Stmts'}) &= \FIRST(\{\T{seq}\} \Seq \{\T{num}, \T{var}, \T{print}, \T{return}\} \Seq (\Empty \cup \FIRST(\Null)))\\
    &= \FIRST(\{\T{seq} \Seq \T{num}, \T{seq} \Seq \T{var}, \T{seq} \Seq \T{print}, \T{seq} \Seq \T{return}\} \Seq \{\Null\})\\
    &= \{\T{seq}\}
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FIRST(\NT{Stmts}) &= \FIRST(\NT{Stmt} \Spc \NT{Stmts'})\\
    &= \FIRST(\FIRST(\NT{Stmt}) \Seq \FIRST(\NT{Stmts'}))\\
    &= \FIRST(\{\T{num}, \T{var}, \T{print}, \T{return}\} \Seq \{\T{seq},\Null\})\\
    &= \FIRST(\{\T{num} \Seq \T{seq}, \T{var} \Seq \T{seq}, \T{print} \Seq \T{seq}, \T{return} \Seq \T{seq}, \T{num}, \T{var}, \T{print}, \T{return}\})\\
    &= \{\T{num}, \T{var}, \T{print}, \T{return}\}\\
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FIRST(\NT{Start}) &= \FIRST(\NT{Stmts})\\
    &= \{\T{num}, \T{var}, \T{print}, \T{return}\}
  \end{aligned}
\end{equation*}

\subsubsection*{{\FOLLOW}}
\begin{equation*}
  \begin{aligned}
    \FOLLOW(\NT{Start}) &= \{\EOF\}
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \NT{Start} &\Arrow \underline{\NT{Stmts}}\\
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FOLLOW(\NT{Stmts}) &= \FIRST(\FIRST(\Null) \Seq \FOLLOW(\NT{Start}))\\
    &= \FIRST(\{\Null\} \Seq \{\EOF\})\\
    &= \FIRST(\{\EOF\})\\
    &= \{\EOF\}
  \end{aligned}
\end{equation*}
Na koncu desne strani produkcije ni "nič", ampak $\Null$!

\begin{equation*}
  \begin{aligned}
    \NT{Stmts} &\Arrow \NT{Stmt} \Spc \underline{\NT{Stmts'}}\\
    \NT{Stmts'} &\Arrow \T{seq} \Spc \NT{Stmt} \Spc \underline{\NT{Stmts'}} \Union \Null\\
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FOLLOW(\NT{Stmts}') &= \FIRST(\FIRST(\Null) \Seq \FOLLOW(\NT{Stmts})) \cup \FIRST(\FIRST(\Null) \Seq \FOLLOW(\NT{Stmts'}))\\
    &= \FIRST(\{\Null\} \Seq \{\EOF\}) \cup \FIRST(\{\Null\} \Seq \Empty)\\
    &= \FIRST(\{\EOF\}) \cup \FIRST(\Empty)\\
    &= \{\EOF\} \cup \Empty\\
    &= \{\EOF\}
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \NT{Stmts} &\Arrow \underline{\NT{Stmt}} \Spc \NT{Stmts'}\\
    \NT{Stmts'} &\Arrow \T{seq} \Spc \underline{\NT{Stmt}} \Spc \NT{Stmts'} \Union \Null\\
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FOLLOW(\NT{Stmt}) &= \FIRST(\FIRST(\NT{Stmts'}) \Seq \FOLLOW(\NT{Stmts})) \cup \FIRST(\FIRST(\NT{Stmts'}) \Seq \FOLLOW(\NT{Stmts'})) \\
    &= \FIRST(\{\T{seq}, \Null\} \Seq \{\EOF\}) \cup \FIRST(\{\T{seq}, \Null\} \Seq \{\EOF\})\\
    &= \{\T{seq}, \EOF\}
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \NT{Stmt} &\Arrow \underline{\NT{Expr}} \Spc \T{to} \Spc \T{var} \Union \T{print} \Spc \underline{\NT{Expr}} \Union \NT{return} \Spc \underline{\NT{Expr}}\\
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FOLLOW(\NT{Expr}) &= \begin{aligned}[t] &\FIRST(\FIRST(\T{to} \Spc \T{var}) \Seq \FOLLOW(\NT{Stmt})) \cup{}\\
    &\FIRST(\FIRST(\Null) \Seq \FOLLOW(\NT{Stmt})) \cup{}\\
    &\FIRST(\FIRST(\Null) \Seq \FOLLOW(\NT{Stmt}))\end{aligned}\\
    &= \FIRST(\{\T{to}\} \Seq \{\T{seq}, \Null\}) \cup \FIRST(\{\Null\} \Seq \{\T{seq}, \EOF\}) \cup \FIRST(\{\Null\} \Seq \{\T{seq}, \EOF\})\\
    &= \FIRST(\{\T{to} \Seq \T{seq}, \T{to} \Seq \Null\}) \cup \FIRST(\{\T{seq}, \EOF\}) \cup \FIRST(\{\T{seq}, \EOF\})\\
    &= \{\T{to}\}) \cup \{\T{seq}, \EOF\} \cup \{\T{seq}, \EOF\}\\
    &= \{\T{to}, \T{seq}, \EOF\}
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \NT{Expr} &\Arrow \underline{\NT{Sub}}\\
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FOLLOW(\NT{Sub}) &= \FIRST(\FIRST(\Null) \Seq \FOLLOW(\NT{Expr})) \\
    &= \FIRST(\{\Null\} \Seq \{\T{to}, \T{seq}, \EOF\})\\
    &= \{\T{to}, \T{seq}, \EOF\}
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \NT{Sub} &\Arrow \NT{Primary} \Spc \underline{\NT{Sub'}}\\
    \NT{Sub'} &\Arrow \T{minus} \Spc \NT{Primary} \Spc \underline{\NT{Sub'}} \Union \Null\\
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FOLLOW(\NT{Sub}') &= \FIRST(\FIRST(\Null) \Seq \FOLLOW(\NT{Sub})) \cup \FIRST(\FIRST(\Null) \Seq \FOLLOW(\NT{Sub'}))\\
    &= \FIRST(\{\Null\} \Seq \{\T{to}, \T{seq}, \EOF\}) \cup \FIRST(\{\Null\} \Seq \Empty)\\
    &= \FIRST(\{\T{to}, \T{seq}, \EOF\}) \cup \FIRST(\Empty)\\
    &= \{\T{to}, \T{seq}, \EOF\} \cup \Empty\\
    &= \{\T{to}, \T{seq}, \EOF\}
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \NT{Sub} &\Arrow \underline{\NT{Primary}} \Spc \NT{Sub'}\\
    \NT{Sub'} &\Arrow \T{minus} \Spc \underline{\NT{Primary}} \Spc \NT{Sub'} \Union \Null\\
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FOLLOW(\NT{Primary}) &= \FIRST(\FIRST(\NT{Sub'}) \Seq \FOLLOW(\NT{Sub})) \cup \FIRST(\FIRST(\NT{Sub'}) \Seq \FOLLOW(\NT{Sub'})) \\
    &= \FIRST(\{\T{minus}, \Null\} \Seq \{\T{to}, \T{seq}, \EOF\}) \cup \FIRST(\{\T{minus}, \Null\} \Seq \{\EOF\})\\
    &= \FIRST(\{\T{minus} \Seq \T{to}, \T{minus} \Seq \T{seq}, \T{minus} \Seq \EOF, \T{to}, \T{seq}, \EOF\}) \cup \FIRST(\{\T{minus} \Seq \EOF, \EOF\})\\ 
    &= \{\T{minus}, \T{to}, \T{seq}, \EOF\} \cup \{\T{minus}, \EOF\}\\
    &= \{\T{minus}, \T{to}, \T{seq}, \EOF\}
  \end{aligned}
\end{equation*}

\subsubsection*{{\FIRST} $\Seq$ {\FOLLOW}}

Možice za vse desne strani produkcije morajo biti tuje, drugače se ne moremo odločiti:

\begin{equation*}
    \NT{Stmts'} \Arrow \T{seq} \Spc \NT{Stmt} \Spc \NT{Stmts'} \Union \Null
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FIRST(\FIRST(\T{seq} \Spc \NT{Stmt} \Spc \NT{Stmts'}) \Seq \FOLLOW(\NT{Stmts'})) &= \FIRST(\{\T{seq}\} \Seq \{\EOF\})\\
    &= \FIRST(\{\T{seq} \Seq \EOF\})\\
    &= \{\T{seq}\}\\
    \FIRST(\FIRST(\Null) \Seq \FOLLOW(\NT{Stmts'})) &= \FIRST(\{\Null\} \Seq \{\EOF\}) \\
    &= \FIRST(\{\EOF\}) \\
    &= \{\EOF\} \\
  \end{aligned}
\end{equation*}

\begin{equation*}
  \{\T{seq}\} \cap \{\EOF\} = \Empty \text{ OK!}
\end{equation*}

\begin{equation*}
    \NT{Stmt} \Arrow \NT{Expr} \Spc \T{to} \Spc \T{var} \Union \T{print} \Spc \NT{Expr} \Union \NT{return} \Spc \NT{Expr}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FIRST(\FIRST(\NT{Expr} \Spc \T{to} \Spc \T{var}) \Seq \FOLLOW(\NT{Stmt})) &= \FIRST(\{\T{num}, \T{var}\} \Seq \{\T{seq}, \EOF\})\\
    &= \FIRST(\{\T{num} \Seq \T{seq}, \T{var} \Seq \T{seq}, \T{num} \Seq \EOF, \T{var} \Seq \EOF \})\\
    &= \{\T{num}, \T{var}\}\\
    \FIRST(\FIRST(\T{print} \Spc \NT{Expr}) \Seq \FOLLOW(\NT{Stmt})) &= \FIRST(\{\T{print}\} \Seq \{\T{seq}, \EOF\})\\
    &= \FIRST(\{\T{print} \Seq \T{seq}, \T{print} \Seq \EOF\})\\
    &= \{\T{print}\}\\
    \FIRST(\FIRST(\NT{return} \Spc \NT{Expr}) \Seq \FOLLOW(\NT{Stmt})) &= \FIRST(\{\T{return}\} \Seq \{\T{seq}, \EOF\})\\
    &= \FIRST(\{\T{return} \Seq \T{seq}, \T{return} \Seq \EOF\})\\
    &= \{\T{return}\}\\
  \end{aligned}
\end{equation*}

\begin{equation*}
  \{\T{num}, \T{var}\} \cap \{\T{print}\} \cap \{\T{return}\} = \Empty \text{ OK!}
\end{equation*}

\begin{equation*}
    \NT{Sub'} \Arrow \T{minus} \Spc \NT{Primary} \Spc \NT{Sub'} \Union \Null
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FIRST(\FIRST(\T{minus} \Spc \NT{Primary} \Spc \NT{Sub'}) \Seq \FOLLOW(\NT{Sub'})) &= \FIRST(\{\T{minus}\} \Seq \{\T{to}, \T{seq}, \EOF\})\\
    &= \FIRST(\{\T{minus} \Seq \T{to}, \T{minus} \Seq \T{seq}, \T{minus} \Seq \EOF\})\\
    &= \{\T{minus}\}\\
    \FIRST(\FIRST(\Null) \Seq \FOLLOW(\NT{Sub'})) &= \FIRST(\{\Null\} \Seq \{\T{to}, \T{seq}, \EOF\})\\
    &= \FIRST(\{\T{to}, \T{seq}, \EOF\})\\
    &= \{\T{to}, \T{seq}, \EOF\}
  \end{aligned}
\end{equation*}

\begin{equation*}
  \{\T{minus}\} \cap \{\T{to}, \T{seq}, \EOF\} = \Empty \text{ OK!}
\end{equation*}

\begin{equation*}
    \NT{Primary} \Arrow \T{num} \Union \T{var}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FIRST(\FIRST(\T{num}) \Seq \FOLLOW(\NT{Primary})) &= \FIRST(\{\T{num}\} \Seq \{\T{minus}, \T{to}, \T{seq}, \EOF\})\\
    &= \FIRST(\{\T{num} \Seq \T{minus}, \T{num} \Seq \T{to}, \T{num} \Seq \T{seq}, \T{num} \Seq \EOF\})\\
    &= \{\T{num}\}\\
    \FIRST(\FIRST(\T{var}) \Seq \FOLLOW(\NT{Primary})) &= \FIRST(\{\T{var}\} \Seq \{\T{minus}, \T{to}, \T{seq}, \EOF\})\\
    &= \FIRST(\{\T{var} \Seq \T{minus}, \T{var} \Seq \T{to}, \T{var} \Seq \T{seq}, \T{var} \Seq \EOF\})\\
    &= \{\T{var}\}
  \end{aligned}
\end{equation*}

\begin{equation*}
  \{\T{num}\} \cap \{\T{var}\} = \Empty \text{ OK!}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \NT{Start} &\Arrow \NT{Stmts}\\
    \NT{Stmts} &\Arrow \NT{Stmt} \Spc \NT{Stmts'}\\
    \NT{Stmts'} &\Arrow \Lookahead{\T{seq}} \T{seq} \Spc \NT{Stmt} \Spc \NT{Stmts'} \Union \Lookahead{\EOF} \Null\\
    \NT{Stmt} &\Arrow \Lookahead{\T{num}, \T{var}} \NT{Expr} \Spc \T{to} \Spc \T{var} \Union \Lookahead{\T{print}} \T{print} \Spc \NT{Expr} \Union \Lookahead{\T{return}}\NT{return} \Spc \NT{Expr}\\
    \NT{Expr} &\Arrow \NT{Sub}\\
    \NT{Sub} &\Arrow \NT{Primary} \Spc \NT{Sub'}\\
    \NT{Sub'} &\Arrow \Lookahead{\T{minus}} \T{minus} \Spc \NT{Primary} \Spc \NT{Sub'} \Union \Lookahead{\T{to}, \T{seq}, \EOF} \Null\\
    \NT{Primary} &\Arrow \Lookahead{\T{num}} \T{num} \Union \Lookahead{\T{var}} \T{var}
  \end{aligned}
\end{equation*}

\newpage
\begin{algorithm}
  function recognizeStart()
    result = recognizeStmts()
    return when lookahead
      $\EOF$ $\rightarrow$ result
      else $\rightarrow$ false

  function recognizeStmts()
    return recognizeStmt() $\&\&$ recognizeStmts'()

  function recognizeStmts'()
    return when lookahead
      $\T{seq}$ $\rightarrow$ recognizeTerminal($\T{seq}$) $\&\&$ recognizeStmt() $\&\&$ recognizeStmts'()
      $\EOF$ $\rightarrow$ true
      else $\rightarrow$ false

  function recognizeStmt()
    return when lookahead
      $\T{num}, \T{var}$ $\rightarrow$ recognizeExpr() $\&\&$ recognizeTerminal($\T{to}$) $\&\&$ recognizeTerminal($\T{var}$)
      $\T{print}$ $\rightarrow$ recognizeTerminal($\T{print}$) $\&\&$ recognizeExpr()
      $\T{return}$ $\rightarrow$ recognizeTerminal($\T{return}$) $\&\&$ recognizeExpr()
      else $\rightarrow$ false

  function recognizeExpr()
    return recognizeSub()

  function recognizeSub()
    return recognizePrimary() $\&\&$ recognizeSub'()

  function recognizeSub'()
    return when lookahead
      $\T{minus}$ $\rightarrow$ recognizeTerminal($\T{minus}$) $\&\&$ recognizePrimary() $\&\&$  recognizeSub'()
      $\T{to}, \T{seq}, \EOF$ $\rightarrow$ true
      else $\rightarrow$ false

  function recognizePrimary()
    return when lookahead
      $\T{num}$ $\rightarrow$ recognizeTerminal($\T{num}$)
      $\T{var}$ $\rightarrow$ recognizeTerminal($\T{var}$)
      else $\rightarrow$ false
\end{algorithm}

\newpage
Primer kode za jezike, ki so bolj podobni C:

\begin{algorithm}
  function recognizeStart()
    result = recognizeStmts()
    if lookahead == $\EOF$
      return result
    else
      return false

  function recognizeStmts()
    return recognizeStmt() $\&\&$ recognizeStmts'()

  function recognizeStmts'()
    switch lookahead
      case $\T{seq}$:
        return recognizeTerminal($\T{seq}$) $\&\&$ recognizeStmt() $\&\&$ recognizeStmts'()
      case $\EOF$:
        return true
      default:
        return false

  function recognizeStmt()
    switch lookahead
      case $\T{num}$:
      case $\T{var}$:
        return recognizeExpr() $\&\&$ recognizeTerminal($\T{to}$) $\&\&$ recognizeTerminal($\T{var}$)
      case $\T{print}$:
        return recognizeTerminal($\T{print}$) $\&\&$ recognizeExpr()
      case $\T{return}$:
        return recognizeTerminal($\T{return}$) $\&\&$ recognizeExpr()
      default:
        return false

  function recognizeExpr()
    return recognizeSub()

  function recognizeSub()
    return recognizePrimary() $\&\&$ recognizeSub'()

  function recognizeSub'()
    switch lookahead
      case $\T{minus}$:
        return recognizeTerminal($\T{minus}$) $\&\&$ recognizePrimary() $\&\&$ recognizeSub'()
      case $\T{to}$:
      case $\T{seq}$:
      case $\EOF$:
       return true
      default:
        return false

  function recognizePrimary()
    switch lookahead
      case $\T{num}$:
        return recognizeTerminal($\T{num}$)
      case $\T{var}$:
        return recognizeTerminal($\T{var}$)
      default:
        return false
\end{algorithm}


\section*{Primeri}

\subsection{Seznam}

\subsubsection*{Jezik}
\begin{verbatim}
  [1]
\end{verbatim}
\begin{verbatim}
  [1, 2, "abc", 3]
\end{verbatim}

\subsubsection*{Regularni izrazi}
\begin{equation*}
  \begin{aligned}
    \T{int} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}\\
    \T{string} &= \Char{"} \Spc \Kleene{(\Alphabet - \{\Char{"}\})} \Spc \Char{"}\\
    \T{comma} &= \Char{,}\\
    \T{lbrak} &= \Char{[}\\
    \T{rbrak} &= \Char{]}\\
  \end{aligned}
\end{equation*}

\subsubsection*{Gramatika}
\begin{equation*}
  \begin{aligned}
    \NT{Start} &\Arrow \NT{List}\\
    \NT{List} &\Arrow \T{lbrak} \Spc \NT{Items} \Spc \T{rbrak}\\
    \NT{Items} &\Arrow \NT{Item} \Spc \NT{Items'}\\
    \NT{Items'} &\Arrow \T{comma} \Spc \NT{Items} \Union \Null\\
    \NT{Item} &\Arrow \T{int} \Union \T{string}
  \end{aligned}
\end{equation*}

\subsubsection*{{\FIRST} \& {\FOLLOW}}
\begin{equation*}
  \begin{aligned}
    \FIRST(\T{int}) &= \{\T{int}\}\\
    \FIRST(\T{string}) &= \{\T{string}\}\\
    \FIRST(\T{comma}) &= \{\T{comma}\}\\
    \FIRST(\T{lbrak}) &= \{\T{lbrak}\}\\
    \FIRST(\T{rbrak}) &= \{\T{rbrak}\}\\
    \FIRST(\NT{Item}) &= \{\T{int}, \T{string}\}\\
    \FIRST(\NT{Item'}) &= \{\T{comma}\}\\
    \FIRST(\NT{Items}) &= \{\T{int}, \T{string}\}\\
    \FIRST(\NT{List}) &= \{\T{lbrak}\}\\
    \FIRST(\NT{Start}) &= \{\T{lbrak}\}\\
    \FIRST(\T{comma} \Seq \NT{Items}) &= \{\T{comma}\}\\
    \FIRST(\NT{Item} \Seq \NT{Items'}) &= \{\T{int}, \T{string}\}\\
    \FIRST(\T{lbrak} \Seq \NT{Items} \Seq \T{rbrak}) &= \{\T{lbrak}\}\\[1em]
    \FOLLOW(\NT{Start}) &= \{\EOF\}\\
    \FOLLOW(\NT{List}) &= \{\EOF\}\\
    \FOLLOW(\NT{Items}) &= \{\T{rbrak}\}\\
    \FOLLOW(\NT{Items'}) &= \{\T{rbrak}\}\\
    \FOLLOW(\NT{Item}) &= \{\T{comma}\}
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FIRST(\FIRST(\T{List}) \Seq \FOLLOW(\NT{Start})) &= \{\T{lbrak}\}\\
    \FIRST(\FIRST(\T{lbrak} \Seq \NT{Items} \Seq \T{rbrak}) \Seq \FOLLOW(\NT{List})) &= \{\T{lbrak}\}\\
    \FIRST(\FIRST(\NT{Item} \Seq \NT{Items'}) \Seq \FOLLOW(\NT{Items})) &= \{\T{int, string}\}\\
    \FIRST(\FIRST(\T{comma} \Seq \NT{Items}) \Seq \FOLLOW(\NT{Items'})) &= \{\T{comma}\}\\
    \FIRST(\FIRST(\Null) \Seq \FOLLOW(\NT{Items'})) &= \{\T{rbrak}\}\\
    \FIRST(\FIRST(\T{int}) \Seq \FOLLOW(\NT{Item})) &= \{\T{int}\}\\
    \FIRST(\FIRST(\T{string}) \Seq \FOLLOW(\NT{Item})) &= \{\T{string}\}\\
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \NT{Start} &\Arrow \Lookahead{\T{lbrak}} \NT{List}\\
    \NT{List} &\Arrow \Lookahead{\T{lbrak}} \T{lbrak} \Spc \NT{Items} \Spc \T{rbrak}\\
    \NT{Items} &\Arrow \Lookahead{\T{int}, \T{string}} \NT{Item} \Spc \NT{Items'}\\
    \NT{Items'} &\Arrow \Lookahead{\T{comma}} \T{comma} \Spc \NT{Items} \Union \Lookahead{\T{rbrak}} \Null\\
    \NT{Item} &\Arrow \Lookahead{\T{int}} \T{int} \Union \Lookahead{\T{string}} \T{string}
  \end{aligned}
\end{equation*}

\subsection{Slovar}

\subsubsection*{Jezik}
\begin{verbatim}
  {}
\end{verbatim}
\begin{verbatim}
  {
    "a": 1;
    "b": "c";
    "d": {};
  }
\end{verbatim}

\subsubsection*{Regularni izrazi}
\begin{equation*}
  \begin{aligned}
    \T{int} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}\\
    \T{string} &= \Char{"} \Spc \Kleene{(\Alphabet - \{\Char{"}\})} \Spc \Char{"}\\
    \T{colon} &= \Char{:}\\
    \T{semi} &= \Char{;}\\
    \T{lbrac} &= \Char{\{}\\
    \T{rbrac} &= \Char{\}}\\
  \end{aligned}
\end{equation*}

\subsubsection*{Gramatika}
\begin{equation*}
  \begin{aligned}
    \NT{Start} &\Arrow \NT{Dict}\\
    \NT{Dict} &\Arrow \T{lbrac} \Spc \NT{Entries} \Spc \T{rbrac}\\
    \NT{Entries} &\Arrow \NT{Entry} \Spc \T{semi} \Spc \NT{Entries} \Union \Null\\
    \NT{Entry} &\Arrow \T{string} \Spc \T{colon} \Spc \NT{Value}\\
    \NT{Value} &\Arrow \T{int} \Union \T{string} \Union \NT{Dict}
  \end{aligned}
\end{equation*}

\subsubsection*{{\FIRST} \& {\FOLLOW}}
\begin{equation*}
  \begin{aligned}
    \FIRST(\T{int}) &= \{\T{int}\}\\
    \FIRST(\T{string}) &= \{\T{string}\}\\
    \FIRST(\T{semi}) &= \{\T{semi}\}\\
    \FIRST(\T{lbrac}) &= \{\T{lbrac}\}\\
    \FIRST(\T{rbrac}) &= \{\T{rbrac}\}\\
    \FIRST(\NT{Dict}) &= \{\T{lbrac}\}\\
    \FIRST(\NT{Value}) &= \{\T{int}, \T{string}, \T{lbrac}\}\\
    \FIRST(\NT{Entry}) &= \{\T{string}\}\\
    \FIRST(\NT{Entries}) &= \{\T{string}\}\\
    \FIRST(\NT{First}) &= \{\T{lbrac}\}\\
    \FIRST(\T{string} \Seq \T{colon} \Seq \NT{Value}) &= \{\T{string}\}\\
    \FIRST(\NT{Entry} \Seq \T{semi} \Seq \NT{Entries}) &= \{\T{string}\}\\
    \FIRST(\T{lbrac} \Seq \NT{Entries} \Seq \T{rbrac}) &= \{\T{lbrac}\}\\[1em]
    \FOLLOW(\NT{Start}) &= \{\EOF\}\\
    \FOLLOW(\NT{Dict}) &= \{\EOF\}\\
    \FOLLOW(\NT{Entries}) &= \{\T{rbrac}\}\\
    \FOLLOW(\NT{Entry}) &= \{\T{semi}\}\\
    \FOLLOW(\NT{Value}) &= \{\T{semi}\}
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FIRST(\FIRST(\NT{Dict}) \Seq \FOLLOW(\NT{Start})) &= \{\T{lbrac}\}\\
    \FIRST(\FIRST(\T{lbrac} \Seq \NT{Entries} \Seq \T{rbrac}) \Seq \FOLLOW(\NT{Dict})) &= \{\T{lbrac}\}\\
    \FIRST(\FIRST(\NT{Entry} \Seq \T{semi} \Seq \NT{Entries}) \Seq \FOLLOW(\NT{Entries})) &= \{\T{string}\}\\
    \FIRST(\FIRST(\Null) \Seq \FOLLOW(\NT{Entries'})) &= \{\T{rbrac}\}\\
    \FIRST(\FIRST(\T{string} \Seq \T{colon} \Seq \NT{Value}) \Seq \FOLLOW(\NT{Entry})) &= \{\T{string}\}\\
    \FIRST(\FIRST(\T{int}) \Seq \FOLLOW(\NT{Value})) &= \{\T{int}\}\\
    \FIRST(\FIRST(\T{string}) \Seq \FOLLOW(\NT{Value})) &= \{\T{string}\}\\
    \FIRST(\FIRST(\T{Dict}) \Seq \FOLLOW(\NT{Value})) &= \{\T{lbrac}\}\\
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \NT{Start} &\Arrow \Lookahead{\T{lbrac}} \NT{Dict}\\
    \NT{Dict} &\Arrow \Lookahead{\T{lbrac}} \T{lbrac} \Spc \NT{Entries} \Spc \T{rbrac}\\
    \NT{Entries} &\Arrow \Lookahead{\T{string}} \NT{Entry} \Spc \T{semi} \Spc \NT{Entries} \Union \Lookahead{\T{rbrac}} \Null\\
    \NT{Entry} &\Arrow \Lookahead{\T{string}} \T{string} \Spc \T{colon} \Spc \NT{Item}\\
    \NT{Item} &\Arrow \Lookahead{\T{int}} \T{int} \Union \Lookahead{\T{string}} \T{string} \Union \Lookahead{\T{lbrac}} \NT{Dict}
  \end{aligned}
\end{equation*}

\subsection{Deklaracija spremenljivke}

\subsubsection*{Jezik}
\begin{verbatim}
Int var;
static Char global;
private static String str;
public static final Int pi;
\end{verbatim}

\subsubsection*{Regularni izrazi}
\begin{equation*}
  \begin{aligned}
    \T{semi} &= \Char{;}\\
    \T{id} &= \Kleene{\{\Char{A}, \dots, \Char{Z}, \Char{a}, \dots, \Char{z}\}}\\
    \T{int} &= \Char{Int}\\
    \T{char} &= \Char{Char}\\
    \T{string} &= \Char{String}\\
    \T{public} &= \Char{public}\\
    \T{protected} &= \Char{protected}\\
    \T{private} &= \Char{private}\\
    \T{static} &= \Char{static}\\
    \T{extern} &= \Char{extern}\\
    \T{final} &= \Char{final}\\
    \T{volatile} &= \Char{volatile}\\
  \end{aligned}
\end{equation*}

\subsubsection*{Gramatika}
\begin{equation*}
  \begin{aligned}
    \NT{Start} &\Arrow \NT{Decl}\\
    \NT{Decl} &\Arrow \NT{Scope} \Spc \NT{Modifier} \Spc \NT{Qualifier} \Spc \NT{Type} \Spc \T{id} \Spc \T{semi}\\
    \NT{Scope} &\Arrow \T{public} \Union \T{protected} \Union \T{private} \Union \Null\\
    \NT{Modifier} &\Arrow \T{static} \Union \T{extern} \Union \Null\\
    \NT{Qualifier} &\Arrow \T{final} \Union \T{volatile} \Union \Null\\
    \NT{Type} &\Arrow \T{int} \Union \T{char} \Union \T{string}\\
  \end{aligned}
\end{equation*}

\subsubsection*{{\FIRST} \& {\FOLLOW}}
\begin{equation*}
  \begin{aligned}
    \FIRST(\T{semi}) &= \{\T{semi}\}\\
    \FIRST(\T{id}) &= \{\T{id}\}\\
    \FIRST(\T{int}) &= \{\T{int}\}\\
    \FIRST(\T{char}) &= \{\T{char}\}\\
    \FIRST(\T{string}) &= \{\T{string}\}\\
    \FIRST(\T{public}) &= \{\T{public}\}\\
    \FIRST(\T{protected}) &= \{\T{protected}\}\\
    \FIRST(\T{private}) &= \{\T{private}\}\\
    \FIRST(\T{static}) &= \{\T{static}\}\\
    \FIRST(\T{extern}) &= \{\T{extern}\}\\
    \FIRST(\T{final}) &= \{\T{final}\}\\
    \FIRST(\T{volatile}) &= \{\T{volatile}\}\\
    \FIRST(\NT{Type}) &= \{\T{int}, \T{char}, \T{string}\} \\
    \FIRST(\NT{Qualifier}) &= \{\T{final}, \T{volatile}\}\\
    \FIRST(\NT{Modifier}) &= \{\T{static}, \T{extern}\}\\
    \FIRST(\NT{Scope}) &= \{\T{public}, \T{protected}, \T{private}\}\\
    \FIRST(\NT{Decl}) &= \begin{aligned}[t]\{&\T{public}, \T{protected}, \T{private}, \T{static}, \T{extern},\\
    &\T{final}, \T{volatile}, \T{int}, \T{char}, \T{string}\}\end{aligned}\\
    \FIRST(\NT{Start}) &= \begin{aligned}[t]\{&\T{public}, \T{protected}, \T{private}, \T{static}, \T{extern},\\
    &\T{final}, \T{volatile}, \T{int}, \T{char}, \T{string}\}\end{aligned}\\
    \FIRST(\NT{Scope} \Seq \NT{Modifier} \Seq \NT{Qualifier} \Seq \NT{Type} \Seq \T{id} \Seq \T{semi}) &= \begin{aligned}[t]\{&\T{public}, \T{protected}, \T{private}, \T{static}, \T{extern},\\
    &\T{final}, \T{volatile}, \T{int}, \T{char}, \T{string}\}\end{aligned}\\[1em]
    \FOLLOW(\NT{Start}) &= \{\EOF\}\\
    \FOLLOW(\NT{Decl}) &= \{\EOF\}\\
    \FOLLOW(\NT{Scope}) &= \{\T{static}, \T{extern}, \T{final}, \T{volatile}, \T{int}, \T{char}, \T{string}\}\\
    \FOLLOW(\NT{Modifier}) &= \{\T{final}, \T{volatile}, \T{int}, \T{char}, \T{string}\}\\
    \FOLLOW(\NT{Qualifier}) &= \{\T{int}, \T{char}, \T{string}\}\\
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \FIRST(\FIRST(\NT{Decl}) \Seq \FOLLOW(\NT{Start})) &= \begin{aligned}[t]\{&\T{public}, \T{protected}, \T{private}, \T{static}, \T{extern},\\
    &\T{final}, \T{volatile}, \T{int}, \T{char}, \T{string}\}\end{aligned}\\
    \FIRST(\FIRST(\T{public}) \Seq \FOLLOW(\NT{Scope})) &= \{\T{public}\}\\
    \FIRST(\FIRST(\T{protected}) \Seq \FOLLOW(\NT{Scope})) &= \{\T{protected}\}\\
    \FIRST(\FIRST(\T{private}) \Seq \FOLLOW(\NT{Scope})) &= \{\T{private}\}\\
    \FIRST(\FIRST(\Null) \Seq \FOLLOW(\NT{Scope})) &= \{\T{static}, \T{extern}, \T{final}, \T{volatile}, \T{int}, \T{char}, \T{string}\}\\
    \FIRST(\FIRST(\T{static}) \Seq \FOLLOW(\NT{Modifier})) &= \{\T{static}\}\\
    \FIRST(\FIRST(\T{extern}) \Seq \FOLLOW(\NT{Modifier})) &= \{\T{extern}\}\\
    \FIRST(\FIRST(\Null) \Seq \FOLLOW(\NT{Modifier})) &= \{\T{final}, \T{volatile}, \T{int}, \T{char}, \T{string}\}\\
    \FIRST(\FIRST(\T{final}) \Seq \FOLLOW(\NT{Qualifier})) &= \{\T{static}\}\\
    \FIRST(\FIRST(\T{volatile}) \Seq \FOLLOW(\NT{Qualifier})) &= \{\T{extern}\}\\
    \FIRST(\FIRST(\Null) \Seq \FOLLOW(\NT{Qualifier})) &= \{\T{int}, \T{char}, \T{string}\}\\
    \FIRST(\FIRST(\T{int}) \Seq \FOLLOW(\NT{Type})) &= \{\T{int}\}\\
    \FIRST(\FIRST(\T{char}) \Seq \FOLLOW(\NT{Type})) &= \{\T{char}\}\\
    \FIRST(\FIRST(\T{string}) \Seq \FOLLOW(\NT{Type})) &= \{\T{string}\}\\
  \end{aligned}
\end{equation*}

\begin{equation*}
  \begin{aligned}
    \NT{Start} &\Arrow \Lookahead{\T{public}, \T{protected}, \T{private}, \T{static}, \T{extern}, \T{final}, \T{volatile}, \T{int}, \T{char}, \T{string}} \NT{Decl}\\
    \NT{Decl} &\Arrow \Lookahead{\T{public}, \T{protected}, \T{private}, \T{static}, \T{extern}, \T{final}, \T{volatile}, \T{int}, \T{char}, \T{string}} \NT{Scope} \Spc \NT{Modifier} \Spc \NT{Qualifier} \Spc \NT{Type} \Spc \T{id} \Spc \T{semi}\\
    \NT{Scope} &\Arrow \Lookahead{\T{public}} \T{public} \Union \Lookahead{\T{protected}} \T{protected} \Union \Lookahead{\T{private}} \T{private} \Union \Lookahead{\T{static}, \T{extern}, \T{final}, \T{volatile}, \T{int}, \T{char}, \T{string}} \Null\\
    \NT{Modifier} &\Arrow \Lookahead{\T{static}} \T{static} \Union \Lookahead{\T{extern}} \T{extern} \Union \Lookahead{\T{final}, \T{volatile}, \T{int}, \T{char}, \T{string}} \Null\\
    \NT{Qualifier} &\Arrow \Lookahead{\T{final}} \T{final} \Union \Lookahead{\T{volatile}} \T{volatile} \Union \Lookahead{\T{int}, \T{char}, \T{string}} \Null\\
    \NT{Type} &\Arrow \Lookahead{\T{int}}  \T{int} \Union \Lookahead{\T{char}} \T{char} \Union \Lookahead{\T{string}} \T{string}\\
  \end{aligned}
\end{equation*}

\subsection{Deklaracija funkcije}

\subsubsection*{Jezik}
\begin{verbatim}
Int fun();
Int add(Int x, Int y);
Bool isZero(Int x);
Unit print();
\end{verbatim}

\subsubsection*{Regularni izrazi}
\begin{equation*}
  \begin{aligned}
    \T{semi} &= \Char{;}\\
    \T{comma} &= \Char{,}\\
    \T{lparen} &= \Char{(}\\
    \T{rparen} &= \Char{)}\\
    \T{id} &= \KleenePlus{\{\Char{A}, \dots, \Char{Z}, \Char{a}, \dots, \Char{z}\}}\\
    \T{unit} &= \Char{Unit}\\
    \T{int} &= \Char{Int}\\
    \T{char} &= \Char{Char}\\
    \T{string} &= \Char{String}\\
  \end{aligned}
\end{equation*}

\subsubsection*{Gramatika}
\begin{equation*}
  \begin{aligned}
    \NT{Start} &\Arrow \NT{Decl}\\
    \NT{Decl} &\Arrow \NT{Type} \Spc \T{id} \Spc \T{lparen} \Spc \NT{Args} \Spc \T{rparen} \Spc \T{semi}\\
    \NT{Args} &\Arrow \NT{Arg} \Spc \NT{Args'} \Union \Null\\
    \NT{Args'} &\Arrow \T{comma} \Spc \NT{Arg} \Spc \NT{Args'} \Union \Null\\
    \NT{Arg} &\Arrow \NT{Type} \Spc \T{id}\\
    \NT{Type} &\Arrow \T{unit} \Union \T{int} \Union \T{char} \Union \T{string}\\
  \end{aligned}
\end{equation*}

\subsubsection*{{\FIRST} \& {\FOLLOW}}
\begin{equation*}
  \begin{aligned}
    \NT{Start} &\Arrow \Lookahead{\T{unit}, \T{int}, \T{char}, \T{string}} \NT{Decl}\\
    \NT{Decl} &\Arrow \Lookahead{\T{unit}, \T{int}, \T{char}, \T{string}} \NT{Type} \Spc \T{id} \Spc \T{lparen} \Spc \NT{Args} \Spc \T{rparen} \Spc \T{semi}\\
    \NT{Args} &\Arrow \Lookahead{\T{unit}, \T{int}, \T{char}, \T{string}} \NT{Arg} \Spc \NT{Args'} \Union \Lookahead{\T{rparen}} \Null\\
    \NT{Args'} &\Arrow \Lookahead{\T{comma}} \T{comma} \Spc \NT{Arg} \Spc \NT{Args'} \Union \Lookahead{\T{rparen}} \Null \\
    \NT{Arg} &\Arrow \Lookahead{\T{unit}, \T{int}, \T{char}, \T{string}} \NT{Type} \Spc \T{id}\\
    \NT{Type} &\Arrow \Lookahead{\T{unit}} \T{unit} \Union \Lookahead{\T{int}} \T{int} \Union \Lookahead{\T{char}} \T{char} \Union \Lookahead{\T{string}} \T{string}\\
  \end{aligned}
\end{equation*}

\subsection{Preprosta Boolova algebra}
\begin{verbatim}
true
true & false => false
true | false & true
(true | false) & true
false => true
\end{verbatim}

\subsubsection*{Regularni izrazi}
\begin{equation*}
  \begin{aligned}
    \T{arrow} &= \Char{=>}\\
    \T{and} &= \Char{\&}\\
    \T{or} &= \Char{|}\\
    \T{true} &= \Char{true}\\
    \T{false} &= \Char{false}\\
    \T{lparen} &= \Char{(}\\
    \T{rparen} &= \Char{)}\\
  \end{aligned}
\end{equation*}

\subsubsection*{Gramatika}
\begin{align*}
  \NT{Start} &\Arrow \NT{Impl}\\[1em]
  \NT{Impl} &\Arrow \NT{Disj} \Spc \NT{Impl'}\\
  \NT{Impl'} &\Arrow \T{arrow} \Spc \NT{Disj} \Spc \NT{Impl'} \Union \Null\\[1em]
  \NT{Disj} &\Arrow \NT{Conj} \Spc \NT{Disj'}\\
  \NT{Disj'} &\Arrow \T{or} \Spc \NT{Conj} \Spc \NT{Disj'} \Union \Null\\[1em]
  \NT{Conj} &\Arrow \NT{Primary} \Spc \NT{Conj'}\\
  \NT{Conj'} &\Arrow \T{and} \Spc \NT{Primary} \Spc \NT{Conj'} \Union \Null\\[1em]
  \NT{Primary} &\Arrow \T{true} \Union \T{false} \Union \T{lparen} \Spc \NT{Impl} \Spc \T{rparen}
\end{align*}

\subsubsection*{{\FIRST} \& {\FOLLOW}}
\begin{align*}
  \NT{Start} &\Arrow \Lookahead{\T{true}, \T{false}, \T{lparen}} \NT{Impl}\\[1em]
  \NT{Impl} &\Arrow \Lookahead{\T{true}, \T{false}, \T{lparen}} \NT{Disj} \Spc \NT{Impl'}\\
  \NT{Impl'} &\Arrow \Lookahead{\T{arrow}} \T{arrow} \Spc \NT{Disj} \Spc \NT{Impl'} \Union \Lookahead{\T{rparen}, \T{\EOF}} \Null\\[1em]
  \NT{Disj} &\Arrow \Lookahead{\T{true}, \T{false}, \T{lparen}} \NT{Conj} \Spc \NT{Disj'}\\
  \NT{Disj'} &\Arrow \Lookahead{\T{or}} \T{or} \Spc \NT{Conj} \Spc \NT{Disj'} \Union \Lookahead{\T{arrow}, \T{rparen}, \T{\EOF}} \Null\\[1em]
  \NT{Conj} &\Arrow \Lookahead{\T{true}, \T{false}, \T{lparen}} \NT{Primary} \Spc \NT{Conj'}\\
  \NT{Conj'} &\Arrow \Lookahead{\T{and}} \T{and} \Spc \NT{Primary} \Spc \NT{Conj'} \Union \Lookahead{\T{or}, \T{arrow}, \T{rparen}, \T{\EOF}} \Null\\[1em]
  \NT{Primary} &\Arrow \Lookahead{\T{true}} \T{true} \Union \Lookahead{\T{false}} \T{false} \Union \Lookahead{\T{lparen}} \T{lparen} \Spc \NT{Impl} \Spc \T{rparen}
\end{align*}

\subsection{BC}
\begin{verbatim}
  a = 1;
  b = 2;
  print a + b;
\end{verbatim}

\subsubsection*{Regularni izrazi}
\begin{equation*}
  \begin{aligned}
    \T{int} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}\\
    \T{id} &= \KleenePlus{\{\Char{a}, \dots, \Char{z}\}}\\
    \T{asign} &= \Char{=}\\
    \T{semi} &= \Char{;}\\
    \T{plus} &= \Char{+}\\
    \T{minus} &= \Char{-}\\
    \T{times} &= \Char{*}\\
    \T{divide} &= \Char{/}\\
    \T{lparen} &= \Char{(}\\
    \T{rparen} &= \Char{)}\\
    \T{print} &= \Char{print}\\
  \end{aligned}
\end{equation*}

\subsubsection*{Gramatika}
\begin{equation*}
  \begin{aligned}
    \NT{Stmts} &\Arrow \NT{Stmt} \Spc \T{semi} \Spc \NT{Stmts} \Union \Null\\
    \NT{Stmt} &\Arrow \T{id} \Spc \T{assign} \Spc \NT{Expr} \Union \T{print} \Spc \NT{Expr}\\
    \NT{Expr} &\Arrow \NT{Term} \Spc \NT{Expr'}\\
    \NT{Expr'} &\Arrow \T{plus} \Spc \NT{Term} \Spc \NT{Expr'} \Union \T{minus} \Spc \NT{Term} \Spc \NT{Expr'} \Union \Null\\
    \NT{Term} &\Arrow \NT{Fac} \Spc \NT{Term'}\\
    \NT{Term'} &\Arrow \T{times} \Spc \NT{Fac} \Spc \NT{Term'} \Union \T{divide} \Spc \NT{Fac} \Spc \NT{Term'} \Union \Null\\
    \NT{Fac} &\Arrow \T{plus} \Spc \NT{Value} \Union \T{minus} \Spc \NT{Value} \Union \NT{Value}\\
    \NT{Value} &\Arrow \T{int} \Union \T{id} \Union \T{lparen} \Spc \NT{Expr} \Spc \T{rparen}
  \end{aligned}
\end{equation*}

\subsection{Lisp}
\begin{verbatim}
  (cons 1 (cons 1 nil))
\end{verbatim}
\begin{verbatim}
  (cons (+ 1 1) 2)
\end{verbatim}
\begin{verbatim}
  (list 1 2 3)
\end{verbatim}

\subsubsection*{Regularni izrazi}
\begin{equation*}
  \begin{aligned}
    \T{nil} &= \Char{n} \Spc \Char{i} \Spc \Char{l}\\
    \T{int} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}\\
    \T{id} &= \KleenePlus{\{\Char{a}, \dots, \Char{z}, \Char{+}, \Char{-}, \Char{*}, \Char{/} \}}\\
    \T{lparen} &= \Char{(}\\
    \T{rparen} &= \Char{)}\\
  \end{aligned}
\end{equation*}

\subsubsection*{Gramatika}
\begin{equation*}
  \begin{aligned}
    \NT{App} &\Arrow \T{lparen} \Spc \NT{Expr} \Spc \NT{Exprs} \Spc \T{rparen}\\
    \NT{Exprs} &\Arrow \NT{Expr} \Spc \NT{Exprs} \Union \Null\\
    \NT{Expr} &\Arrow \T{int} \Union \T{id} \Union \T{nil} \Union \NT{App}
  \end{aligned}
\end{equation*}

\subsection{DC}
\begin{verbatim}
  10 3 *
\end{verbatim}
\begin{verbatim}
  1 2 + 3 *
\end{verbatim}
\begin{verbatim}
  8 9 / 1 +
\end{verbatim}

\subsubsection*{Regularni izrazi}
\begin{equation*}
  \begin{aligned}
    \T{int} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}\\
    \T{operation} &= \{\Char{+}, \Char{-}, \Char{*}, \Char{/}\}
  \end{aligned}
\end{equation*}

\subsubsection*{Gramatika}
\begin{equation*}
  \begin{aligned}
    \NT{Cmds} &\Arrow \NT{Cmd} \Spc \NT{Cmds} \Union \Null \\
    \NT{Cmd} &\Arrow \T{int} \Union \T{operation}\\
  \end{aligned}
\end{equation*}

\subsection{JSON}
\begin{verbatim}
  "b"
\end{verbatim}
\begin{verbatim}
  [1, 2, 3]
\end{verbatim}
\begin{verbatim}
  {
    "a": [1, 2, 3];
    "b": "c";
    "d": {"a": 1;};
  }
\end{verbatim}

\subsection{Graphviz}
\begin{verbatim}
  graph {}
\end{verbatim}
\begin{verbatim}
  graph {
    A;
  }
\end{verbatim}
\begin{verbatim}
  graph {
    A; B; C;
    A -- A;
    B -- C;
    A -- C;
  }
\end{verbatim}


\chapter{Sintaktična drevesa}

Sintaktična drevesa je najlažje predstaviti z drevesnimi gramatikami.

\section{Drevesne gramatike}

Podobno kot lahko imamo gramatike nad nizi, lahko imamo gramatike nad drevesi.
V primeru dreves so terminali vozlišča z $n$ otroci, za $n = 0, 1, 2 \dots$.

\Ex
\begin{equation*}
  \begin{aligned}
    List &\Arrow cell(Num, List) \Union end()\\
    Num &\Arrow int()\\[1em]
    List &\Derive cell(Num, List)\\
      &\Derive cell(int(), List)\\
      &\Derive cell(int(), cell(Num, List))\\
      &\Derive cell(int(), cell(int(), List))\\
      &\Derive cell(int(), cell(int(), cell(Num, List)))\\
      &\Derive cell(int(), cell(int(), cell(int(), end())))\\
  \end{aligned}
\end{equation*}

\Ex
\begin{equation*}
  \begin{aligned}
    Binary &\Arrow node(Binary, Num, Binary) \Union leaf()\\
    Num &\Arrow int()\\[1em]
    Binary &\Derive node(Binary, Num, Binary)\\
      &\Derive node(node(Binary, Num, Binary), Num, Binary)\\
      &\Derive node(node(leaf(), Num, Binary), Num, Binary)\\
      &\Derive node(node(leaf(), int(), Binary), Num, Binary)\\
      &\Derive node(node(leaf(), int(), leaf()), Num, Binary)\\
      &\Derive node(node(leaf(), int(), leaf()), int(), Binary)\\
      &\Derive node(node(leaf(), int(), leaf()), int(), node(Binary, Num, Binary))\\
      &\Derive node(node(leaf(), int(), leaf()), int(), node(leaf(), Num, Binary))\\
      &\Derive node(node(leaf(), int(), leaf()), int(), node(leaf(), int(), Binary))\\
      &\Derive node(node(leaf(), int(), leaf()), int(), node(leaf(), int(), leaf()))\\
  \end{aligned}
\end{equation*}

\subsubsection*{Implementacija}
Drevesne gramatike lahko implementiramo na več načinov.

V OOP jezikih vozlišča predstavimo kot kompozicijo (vprašamo se z in) in operacijo $(\Union)$ kot dedovanje iz vmesnika (vprašamo se z ali).
Spomnite se, da obstajata dve obliki dedovanja:
\begin{itemize}
  \item Dedovanje iz vmesnika, katerega namen je posplošitev.
    Torej imamo več razredov, ki jih lahko uporabljamo na enak način (imajo enake metode).
  \item Dedovanje iz razreda, katerega namen je pouporaba.
    Torej želimo implementirati različico nekega razreda ali pa imamo pripravljeno delno implementacijo razreda, na podlagi katere ustvarjamo nove razrede.
\end{itemize}

\Ex

Seznam je \textbf{ali} celica, ki vsebuje vrednost \textbf{in} preostanek seznama, \textbf{ali} konec seznama.

\begin{center}
\begin{tikzpicture}[draw, minimum width=0.5cm, minimum height=0.5cm]
    \node[draw] (h1) at (0, 0) {};
    \node[draw] (t1) at (0.5, 0) {};

    \node[draw] (h2) at (2, 0) {};
    \node[draw] (t2) at (2.5, 0) {};

    \node[draw] (h3) at (4, 0) {};
    \node[draw] (t3) at (4.5, 0) {};

    \node[draw] (e) at (6, 0) {};
    \path (e) pic {cross=0.35cm};

    \draw (t1.center) edge[{Circle[]}-{Straight Barb[]}] (h2);
    \draw (t2.center) edge[{Circle[]}-{Straight Barb[]}] (h3);
    \draw (t3.center) edge[{Circle[]}-{Straight Barb[]}] (e);
\end{tikzpicture}
\end{center}

\Ex

Binarno drevo je \textbf{ali} vozlišče, ki vsebuje levega otroka \textbf{in} vrednost \textbf{in} desnega otroka, \textbf{ali} list.

\begin{center}
\begin{tikzpicture}[draw, minimum width=0.5cm, minimum height=0.5cm]
    \node[draw] (l1) at (-0.5, 0) {};
    \node[draw] (v1) at (0, 0) {};
    \node[draw] (r1) at (0.5, 0) {};

    \node[draw] (l2) at (-3, -1) {};
    \node[draw] (v2) at (-2.5, -1) {};
    \node[draw] (r2) at (-2, -1) {};

    \node[draw] (l3) at (2, -1) {};
    \node[draw] (v3) at (2.5, -1) {};
    \node[draw] (r3) at (3, -1) {};

    \node[draw] (e1) at (-4, -2) {};
    \node[draw] (e2) at (-1, -2) {};

    \node[draw] (e3) at (4, -2) {};
    \node[draw] (e4) at (1, -2) {};
    \path (e1) pic {cross=0.35cm};
    \path (e2) pic {cross=0.35cm};
    \path (e3) pic {cross=0.35cm};
    \path (e4) pic {cross=0.35cm};

    \draw (l1.center) edge[{Circle[]}-{Straight Barb[]}] (v2.north);
    \draw (r1.center) edge[{Circle[]}-{Straight Barb[]}] (v3.north);
    \draw (l2.center) edge[{Circle[]}-{Straight Barb[]}] (e1.north);
    \draw (r2.center) edge[{Circle[]}-{Straight Barb[]}] (e2.north);
    \draw (l3.center) edge[{Circle[]}-{Straight Barb[]}] (e4.north);
    \draw (r3.center) edge[{Circle[]}-{Straight Barb[]}] (e3.north);
\end{tikzpicture}
\end{center}

V funkcijskih jezikih vozlišča predstavimo kot tuple ali record in operacijo ${(\Union)}$ kot označeno unijo.
Mogoče pa ju je implementirati tudi izključno z uporabo funkcij (Church encoding).

V C++ lahko uporabimo OOP implementacijo ali pa vozlišča predstavimo kot \texttt{struct} in operacijo ${(\Union)}$ kot kombinacijo \texttt{union} in oznake (torej implementiramo označeno unijo).
V novejših standardih, implementacija označene unije že obstaja v standardni knjižnici \texttt{std::variant}.

\section{Abstraktno sintaktično drevo}
Za vsak programski jezik obstaja abstraktna gramatika, ki pa je zaradi omejitev razčlenjevalnikov pogosto ne moremo direktno uporabiti.
Če to abstraktno gramatiko pretvorimo v drevesno gramatiko dobimo abstraktno sintaktično drevo (AST).

\Ex
\begin{equation*}
  \begin{aligned}[t]
    \NT{Numbers} \Arrow \T{num} \Spc \NT{Numbers} \Union \Null\\[1em]
    \T{num} = \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}
  \end{aligned}
  \qquad
  \begin{aligned}[t]
    Numbers &\Arrow cell(Int, Numbers) \Union end()\\
  \end{aligned}
\end{equation*}
Pretvorba je 1:1, vsako desno stran pretvorimo v vozlišče.
Za terminale, če je mogoče, uporabimo vgrajene tipe.

\Ex
\begin{equation*}
  \begin{aligned}[t]
    \NT{Expr} &\Arrow \NT{Expr} \Spc \T{plus} \Spc \NT{Expr} \\
    &\Union \NT{Expr} \Spc \T{minus} \Spc \NT{Expr} \\
    &\Union \T{num}\\
    &\Union \T{var}\\[1em]
    \T{num} &= \KleenePlus{\{\Char{0}, \dots, \Char{9}\}}\\
    \T{char} &= \{\Char{A}, \dots, \Char{Z}, \Char{a}, \dots, \Char{z}, \Char{0}, \dots, \Char{9} \}\\
    \T{var} &= \KleenePlus{\T{char}}\\
    \T{plus} &= \Char{+}\\
    \T{minus} &= \Char{-}\\
  \end{aligned}
  \qquad
  \begin{aligned}[t]
    Expr &\Arrow plus(Expr, Expr) \\
    &\Union minus(Expr, Expr) \\
    &\Union num(Int)\\
    &\Union var(String)
  \end{aligned}
\end{equation*}
Terminale, ki imajo fiksno vrednost lahko izpustimo iz AST.
Izrazi so zelo podobni binarnim drevesom, le da imamo različno vrsto vozlišča za vsako operacijo.

\Ex
\begin{equation*}
  \begin{aligned}[t]
    \NT{Stmts} &\Arrow \NT{Stmt} \Spc \NT{Stmts}\\
    &\Union \Null\\
    \NT{Stmt} &\Arrow \NT{Var} \Spc \T{assign} \Spc \NT{Expr}\\
    &\Union \T{print} \Spc \NT{Expr}\\[1em]
    \T{char} &= \{\Char{A}, \dots, \Char{Z}, \Char{a}, \dots, \Char{z}, \Char{0}, \dots, \Char{9} \}\\
    \T{var} &= \KleenePlus{\T{char}}\\
    \T{assign} &= \Char{=}\\
    \T{semi} &= \Char{;}\\
    \T{print} &= \Char{print}\\
  \end{aligned}
  \qquad
  \begin{aligned}[t]
    Stmts &\Arrow seq(Stmt, Stmts) \\
    &\Union end()\\
    Stmt &\Arrow assign(String, Expr) \\
    &\Union print(Expr)
  \end{aligned}
\end{equation*}
Izjave lahko predstavimo kot sezname. Lahko pa bi jih predstavili tudi kot izraze, z operatorjem $seq$.

\section{Konkretno sintaktično drevo}
Za razčlenjevanje moramo abstraktno gramatiko preoblikovati.
Če preoblikovano gramatiko pretvorimo v podatkoven tip dobimo konkretno sintaktično drevo (CST).
Ker je nadaljnje transformacije lažje izvesti nad AST, vedno najprej pretvorimo CST v AST.
Pretvorbo je mogoče izvesti kar med razčlenjevanjem (torej CST ne potrebujemo).

\chapter{XML sheme}

Imamo lahko tudi drevesne gramatike, kjer imajo vozljišča poljubno število otrok.
Torej otroci vozlišča spet tvorijo jezik.
Če se omejimo na regularne jezike jih lahko opišemo z regularnimi izrazi.
Primer takšnih dreves sta XML in sintaktična drevesa EBNF gramatik.

\Ex
\begin{equation*}
  \begin{aligned}
    Doc &\Arrow inventory(\Kleene{Item})\\
    Item &\Arrow desk(Desk) \Union chair(Chair) \Union computer(Computer) \\
    Info &\Arrow location(Location) \Seq \KleenePlus{user(User)}\\
    Location &\Arrow building(String) \Seq room(Room)\\
    User &\Arrow name(Capitalized) \Seq surname(Capitalized) \Seq \Opt{role(Role)}\\
    Desk &\Arrow Info \Seq standing(Boolean)\\
    Chair &\Arrow Info\\
    Computer &\Arrow Info \Seq cpu(Quantity) \Seq memory(Quantity) \Seq disk(Quantity)\\
    Capitalized &\Arrow String\\
    Role &\Arrow String\\
    Room &\Arrow Integer\\
    Quantity &\Arrow Float\\
  \end{aligned}
\end{equation*}
\newpage

\begin{lstlisting}
<inventory>
  <desk>
    <location>
      <building>G3</building>
      <room>13</room>
    </location>
    <user>
      <name>Albert</name>
      <surname>Einstein</surname>
      <role>Researcher</role>
    </user>
    <user>
      <name>Joe</name>
      <surname>Biden</surname>
    </user>
    <standing>false</standing>
  </desk>
  <computer>
    <location>
      <building>G3</building>
      <room>14</room>
    </location>
    <user>
      <name>Angelina</name>
      <surname>Jolie</surname>
      <role>Teacher</role>
    </user>
    <cpu>4.2</cpu>
    <memory>10.0</memory>
    <disk>10.0</disk>
  </computer>
  <chair>
    <location>
      <building>G3</building>
      <room>14</room>
    </location>
    <user>
      <name>Issac</name>
      <surname>Newton</surname>
      <role>Researcher</role>
    </user>
  </chair>
</inventory>
\end{lstlisting}

\end{document}
